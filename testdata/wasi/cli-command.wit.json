{
  "worlds": [
    {
      "name": "command",
      "imports": {
        "interface-17": {
          "interface": {
            "id": 17
          }
        },
        "interface-18": {
          "interface": {
            "id": 18
          }
        },
        "interface-0": {
          "interface": {
            "id": 0
          }
        },
        "interface-1": {
          "interface": {
            "id": 1
          }
        },
        "interface-2": {
          "interface": {
            "id": 2
          }
        },
        "interface-20": {
          "interface": {
            "id": 20
          }
        },
        "interface-21": {
          "interface": {
            "id": 21
          }
        },
        "interface-22": {
          "interface": {
            "id": 22
          }
        },
        "interface-23": {
          "interface": {
            "id": 23
          }
        },
        "interface-24": {
          "interface": {
            "id": 24
          }
        },
        "interface-25": {
          "interface": {
            "id": 25
          }
        },
        "interface-26": {
          "interface": {
            "id": 26
          }
        },
        "interface-27": {
          "interface": {
            "id": 27
          }
        },
        "interface-3": {
          "interface": {
            "id": 3
          }
        },
        "interface-4": {
          "interface": {
            "id": 4
          }
        },
        "interface-5": {
          "interface": {
            "id": 5
          }
        },
        "interface-6": {
          "interface": {
            "id": 6
          }
        },
        "interface-7": {
          "interface": {
            "id": 7
          }
        },
        "interface-8": {
          "interface": {
            "id": 8
          }
        },
        "interface-12": {
          "interface": {
            "id": 12
          }
        },
        "interface-13": {
          "interface": {
            "id": 13
          }
        },
        "interface-10": {
          "interface": {
            "id": 10
          }
        },
        "interface-11": {
          "interface": {
            "id": 11
          }
        },
        "interface-9": {
          "interface": {
            "id": 9
          }
        },
        "interface-16": {
          "interface": {
            "id": 16
          }
        },
        "interface-15": {
          "interface": {
            "id": 15
          }
        },
        "interface-14": {
          "interface": {
            "id": 14
          }
        }
      },
      "exports": {
        "interface-19": {
          "interface": {
            "id": 19
          }
        }
      },
      "package": 5
    }
  ],
  "interfaces": [
    {
      "name": "error",
      "types": {
        "error": 0
      },
      "functions": {
        "[method]error.to-debug-string": {
          "name": "[method]error.to-debug-string",
          "kind": {
            "method": 0
          },
          "params": [
            {
              "name": "self",
              "type": 1
            }
          ],
          "result": "string",
          "docs": {
            "contents": "Returns a string that is suitable to assist humans in debugging\nthis error.\n\nWARNING: The returned string should not be consumed mechanically!\nIt may change across platforms, hosts, or other implementation\ndetails. Parsing this string is a major platform-compatibility\nhazard."
          }
        }
      },
      "package": 0
    },
    {
      "name": "poll",
      "types": {
        "pollable": 2
      },
      "functions": {
        "[method]pollable.block": {
          "name": "[method]pollable.block",
          "kind": {
            "method": 2
          },
          "params": [
            {
              "name": "self",
              "type": 3
            }
          ],
          "docs": {
            "contents": "`block` returns immediately if the pollable is ready, and otherwise\nblocks until ready.\n\nThis function is equivalent to calling `poll.poll` on a list\ncontaining only this pollable."
          }
        },
        "[method]pollable.ready": {
          "name": "[method]pollable.ready",
          "kind": {
            "method": 2
          },
          "params": [
            {
              "name": "self",
              "type": 3
            }
          ],
          "result": "bool",
          "docs": {
            "contents": "Return the readiness of a pollable. This function never blocks.\n\nReturns `true` when the pollable is ready, and `false` otherwise."
          }
        },
        "poll": {
          "name": "poll",
          "kind": "freestanding",
          "params": [
            {
              "name": "in",
              "type": 4
            }
          ],
          "result": 5,
          "docs": {
            "contents": "Poll for completion on a set of pollables.\n\nThis function takes a list of pollables, which identify I/O sources of\ninterest, and waits until one or more of the events is ready for I/O.\n\nThe result `list<u32>` contains one or more indices of handles in the\nargument list that is ready for I/O.\n\nIf the list contains more elements than can be indexed with a `u32`\nvalue, this function traps.\n\nA timeout can be implemented by adding a pollable from the\nwasi-clocks API to the list.\n\nThis function does not return a `result`; polling in itself does not\ndo any I/O so it doesn't fail. If any of the I/O sources identified by\nthe pollables has an error, it is indicated by marking the source as\nbeing reaedy for I/O."
          }
        }
      },
      "docs": {
        "contents": "A poll API intended to let users wait for I/O events on multiple handles\nat once."
      },
      "package": 0
    },
    {
      "name": "streams",
      "types": {
        "error": 6,
        "pollable": 7,
        "stream-error": 9,
        "input-stream": 10,
        "output-stream": 11
      },
      "functions": {
        "[method]input-stream.blocking-read": {
          "name": "[method]input-stream.blocking-read",
          "kind": {
            "method": 10
          },
          "params": [
            {
              "name": "self",
              "type": 12
            },
            {
              "name": "len",
              "type": "u64"
            }
          ],
          "result": 14,
          "docs": {
            "contents": "Read bytes from a stream, after blocking until at least one byte can\nbe read. Except for blocking, behavior is identical to `read`."
          }
        },
        "[method]input-stream.blocking-skip": {
          "name": "[method]input-stream.blocking-skip",
          "kind": {
            "method": 10
          },
          "params": [
            {
              "name": "self",
              "type": 12
            },
            {
              "name": "len",
              "type": "u64"
            }
          ],
          "result": 15,
          "docs": {
            "contents": "Skip bytes from a stream, after blocking until at least one byte\ncan be skipped. Except for blocking behavior, identical to `skip`."
          }
        },
        "[method]input-stream.read": {
          "name": "[method]input-stream.read",
          "kind": {
            "method": 10
          },
          "params": [
            {
              "name": "self",
              "type": 12
            },
            {
              "name": "len",
              "type": "u64"
            }
          ],
          "result": 14,
          "docs": {
            "contents": "Perform a non-blocking read from the stream.\n\nWhen the source of a `read` is binary data, the bytes from the source\nare returned verbatim. When the source of a `read` is known to the\nimplementation to be text, bytes containing the UTF-8 encoding of the\ntext are returned.\n\nThis function returns a list of bytes containing the read data,\nwhen successful. The returned list will contain up to `len` bytes;\nit may return fewer than requested, but not more. The list is\nempty when no bytes are available for reading at this time. The\npollable given by `subscribe` will be ready when more bytes are\navailable.\n\nThis function fails with a `stream-error` when the operation\nencounters an error, giving `last-operation-failed`, or when the\nstream is closed, giving `closed`.\n\nWhen the caller gives a `len` of 0, it represents a request to\nread 0 bytes. If the stream is still open, this call should\nsucceed and return an empty list, or otherwise fail with `closed`.\n\nThe `len` parameter is a `u64`, which could represent a list of u8 which\nis not possible to allocate in wasm32, or not desirable to allocate as\nas a return value by the callee. The callee may return a list of bytes\nless than `len` in size while more bytes are available for reading."
          }
        },
        "[method]input-stream.skip": {
          "name": "[method]input-stream.skip",
          "kind": {
            "method": 10
          },
          "params": [
            {
              "name": "self",
              "type": 12
            },
            {
              "name": "len",
              "type": "u64"
            }
          ],
          "result": 15,
          "docs": {
            "contents": "Skip bytes from a stream. Returns number of bytes skipped.\n\nBehaves identical to `read`, except instead of returning a list\nof bytes, returns the number of bytes consumed from the stream."
          }
        },
        "[method]input-stream.subscribe": {
          "name": "[method]input-stream.subscribe",
          "kind": {
            "method": 10
          },
          "params": [
            {
              "name": "self",
              "type": 12
            }
          ],
          "result": 18,
          "docs": {
            "contents": "Create a `pollable` which will resolve once either the specified stream\nhas bytes available to read or the other end of the stream has been\nclosed.\nThe created `pollable` is a child resource of the `input-stream`.\nImplementations may trap if the `input-stream` is dropped before\nall derived `pollable`s created with this function are dropped."
          }
        },
        "[method]output-stream.blocking-flush": {
          "name": "[method]output-stream.blocking-flush",
          "kind": {
            "method": 11
          },
          "params": [
            {
              "name": "self",
              "type": 16
            }
          ],
          "result": 17,
          "docs": {
            "contents": "Request to flush buffered output, and block until flush completes\nand stream is ready for writing again."
          }
        },
        "[method]output-stream.blocking-splice": {
          "name": "[method]output-stream.blocking-splice",
          "kind": {
            "method": 11
          },
          "params": [
            {
              "name": "self",
              "type": 16
            },
            {
              "name": "src",
              "type": 12
            },
            {
              "name": "len",
              "type": "u64"
            }
          ],
          "result": 15,
          "docs": {
            "contents": "Read from one stream and write to another, with blocking.\n\nThis is similar to `splice`, except that it blocks until the\n`output-stream` is ready for writing, and the `input-stream`\nis ready for reading, before performing the `splice`."
          }
        },
        "[method]output-stream.blocking-write-and-flush": {
          "name": "[method]output-stream.blocking-write-and-flush",
          "kind": {
            "method": 11
          },
          "params": [
            {
              "name": "self",
              "type": 16
            },
            {
              "name": "contents",
              "type": 13
            }
          ],
          "result": 17,
          "docs": {
            "contents": "Perform a write of up to 4096 bytes, and then flush the stream. Block\nuntil all of these operations are complete, or an error occurs.\n\nThis is a convenience wrapper around the use of `check-write`,\n`subscribe`, `write`, and `flush`, and is implemented with the\nfollowing pseudo-code:\n\n```text\nlet pollable = this.subscribe();\nwhile !contents.is_empty() {\n// Wait for the stream to become writable\npollable.block();\nlet Ok(n) = this.check-write(); // eliding error handling\nlet len = min(n, contents.len());\nlet (chunk, rest) = contents.split_at(len);\nthis.write(chunk  );            // eliding error handling\ncontents = rest;\n}\nthis.flush();\n// Wait for completion of `flush`\npollable.block();\n// Check for any errors that arose during `flush`\nlet _ = this.check-write();         // eliding error handling\n```"
          }
        },
        "[method]output-stream.blocking-write-zeroes-and-flush": {
          "name": "[method]output-stream.blocking-write-zeroes-and-flush",
          "kind": {
            "method": 11
          },
          "params": [
            {
              "name": "self",
              "type": 16
            },
            {
              "name": "len",
              "type": "u64"
            }
          ],
          "result": 17,
          "docs": {
            "contents": "Perform a write of up to 4096 zeroes, and then flush the stream.\nBlock until all of these operations are complete, or an error\noccurs.\n\nThis is a convenience wrapper around the use of `check-write`,\n`subscribe`, `write-zeroes`, and `flush`, and is implemented with\nthe following pseudo-code:\n\n```text\nlet pollable = this.subscribe();\nwhile num_zeroes != 0 {\n// Wait for the stream to become writable\npollable.block();\nlet Ok(n) = this.check-write(); // eliding error handling\nlet len = min(n, num_zeroes);\nthis.write-zeroes(len);         // eliding error handling\nnum_zeroes -= len;\n}\nthis.flush();\n// Wait for completion of `flush`\npollable.block();\n// Check for any errors that arose during `flush`\nlet _ = this.check-write();         // eliding error handling\n```"
          }
        },
        "[method]output-stream.check-write": {
          "name": "[method]output-stream.check-write",
          "kind": {
            "method": 11
          },
          "params": [
            {
              "name": "self",
              "type": 16
            }
          ],
          "result": 15,
          "docs": {
            "contents": "Check readiness for writing. This function never blocks.\n\nReturns the number of bytes permitted for the next call to `write`,\nor an error. Calling `write` with more bytes than this function has\npermitted will trap.\n\nWhen this function returns 0 bytes, the `subscribe` pollable will\nbecome ready when this function will report at least 1 byte, or an\nerror."
          }
        },
        "[method]output-stream.flush": {
          "name": "[method]output-stream.flush",
          "kind": {
            "method": 11
          },
          "params": [
            {
              "name": "self",
              "type": 16
            }
          ],
          "result": 17,
          "docs": {
            "contents": "Request to flush buffered output. This function never blocks.\n\nThis tells the output-stream that the caller intends any buffered\noutput to be flushed. the output which is expected to be flushed\nis all that has been passed to `write` prior to this call.\n\nUpon calling this function, the `output-stream` will not accept any\nwrites (`check-write` will return `ok(0)`) until the flush has\ncompleted. The `subscribe` pollable will become ready when the\nflush has completed and the stream can accept more writes."
          }
        },
        "[method]output-stream.splice": {
          "name": "[method]output-stream.splice",
          "kind": {
            "method": 11
          },
          "params": [
            {
              "name": "self",
              "type": 16
            },
            {
              "name": "src",
              "type": 12
            },
            {
              "name": "len",
              "type": "u64"
            }
          ],
          "result": 15,
          "docs": {
            "contents": "Read from one stream and write to another.\n\nThe behavior of splice is equivelant to:\n1. calling `check-write` on the `output-stream`\n2. calling `read` on the `input-stream` with the smaller of the\n`check-write` permitted length and the `len` provided to `splice`\n3. calling `write` on the `output-stream` with that read data.\n\nAny error reported by the call to `check-write`, `read`, or\n`write` ends the splice and reports that error.\n\nThis function returns the number of bytes transferred; it may be less\nthan `len`."
          }
        },
        "[method]output-stream.subscribe": {
          "name": "[method]output-stream.subscribe",
          "kind": {
            "method": 11
          },
          "params": [
            {
              "name": "self",
              "type": 16
            }
          ],
          "result": 18,
          "docs": {
            "contents": "Create a `pollable` which will resolve once the output-stream\nis ready for more writing, or an error has occured. When this\npollable is ready, `check-write` will return `ok(n)` with n>0, or an\nerror.\n\nIf the stream is closed, this pollable is always ready immediately.\n\nThe created `pollable` is a child resource of the `output-stream`.\nImplementations may trap if the `output-stream` is dropped before\nall derived `pollable`s created with this function are dropped."
          }
        },
        "[method]output-stream.write": {
          "name": "[method]output-stream.write",
          "kind": {
            "method": 11
          },
          "params": [
            {
              "name": "self",
              "type": 16
            },
            {
              "name": "contents",
              "type": 13
            }
          ],
          "result": 17,
          "docs": {
            "contents": "Perform a write. This function never blocks.\n\nWhen the destination of a `write` is binary data, the bytes from\n`contents` are written verbatim. When the destination of a `write` is\nknown to the implementation to be text, the bytes of `contents` are\ntranscoded from UTF-8 into the encoding of the destination and then\nwritten.\n\nPrecondition: check-write gave permit of Ok(n) and contents has a\nlength of less than or equal to n. Otherwise, this function will trap.\n\nreturns Err(closed) without writing if the stream has closed since\nthe last call to check-write provided a permit."
          }
        },
        "[method]output-stream.write-zeroes": {
          "name": "[method]output-stream.write-zeroes",
          "kind": {
            "method": 11
          },
          "params": [
            {
              "name": "self",
              "type": 16
            },
            {
              "name": "len",
              "type": "u64"
            }
          ],
          "result": 17,
          "docs": {
            "contents": "Write zeroes to a stream.\n\nThis should be used precisely like `write` with the exact same\npreconditions (must use check-write first), but instead of\npassing a list of bytes, you simply pass the number of zero-bytes\nthat should be written."
          }
        }
      },
      "docs": {
        "contents": "WASI I/O is an I/O abstraction API which is currently focused on providing\nstream types.\n\nIn the future, the component model is expected to add built-in stream types;\nwhen it does, they are expected to subsume this API."
      },
      "package": 0
    },
    {
      "name": "monotonic-clock",
      "types": {
        "pollable": 19,
        "instant": 20,
        "duration": 21
      },
      "functions": {
        "now": {
          "name": "now",
          "kind": "freestanding",
          "params": [],
          "result": 20,
          "docs": {
            "contents": "Read the current value of the clock.\n\nThe clock is monotonic, therefore calling this function repeatedly will\nproduce a sequence of non-decreasing values."
          }
        },
        "resolution": {
          "name": "resolution",
          "kind": "freestanding",
          "params": [],
          "result": 21,
          "docs": {
            "contents": "Query the resolution of the clock. Returns the duration of time\ncorresponding to a clock tick."
          }
        },
        "subscribe-instant": {
          "name": "subscribe-instant",
          "kind": "freestanding",
          "params": [
            {
              "name": "when",
              "type": 20
            }
          ],
          "result": 23,
          "docs": {
            "contents": "Create a `pollable` which will resolve once the specified instant\noccured."
          }
        },
        "subscribe-duration": {
          "name": "subscribe-duration",
          "kind": "freestanding",
          "params": [
            {
              "name": "when",
              "type": 21
            }
          ],
          "result": 23,
          "docs": {
            "contents": "Create a `pollable` which will resolve once the given duration has\nelapsed, starting at the time at which this function was called.\noccured."
          }
        }
      },
      "docs": {
        "contents": "WASI Monotonic Clock is a clock API intended to let users measure elapsed\ntime.\n\nIt is intended to be portable at least between Unix-family platforms and\nWindows.\n\nA monotonic clock is a clock which has an unspecified initial value, and\nsuccessive reads of the clock will produce non-decreasing values.\n\nIt is intended for measuring elapsed time."
      },
      "package": 1
    },
    {
      "name": "wall-clock",
      "types": {
        "datetime": 22
      },
      "functions": {
        "now": {
          "name": "now",
          "kind": "freestanding",
          "params": [],
          "result": 22,
          "docs": {
            "contents": "Read the current value of the clock.\n\nThis clock is not monotonic, therefore calling this function repeatedly\nwill not necessarily produce a sequence of non-decreasing values.\n\nThe returned timestamps represent the number of seconds since\n1970-01-01T00:00:00Z, also known as [POSIX's Seconds Since the Epoch],\nalso known as [Unix Time].\n\nThe nanoseconds field of the output is always less than 1000000000.\n\n[POSIX's Seconds Since the Epoch]: https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16\n[Unix Time]: https://en.wikipedia.org/wiki/Unix_time"
          }
        },
        "resolution": {
          "name": "resolution",
          "kind": "freestanding",
          "params": [],
          "result": 22,
          "docs": {
            "contents": "Query the resolution of the clock.\n\nThe nanoseconds field of the output is always less than 1000000000."
          }
        }
      },
      "docs": {
        "contents": "WASI Wall Clock is a clock API intended to let users query the current\ntime. The name \"wall\" makes an analogy to a \"clock on the wall\", which\nis not necessarily monotonic as it may be reset.\n\nIt is intended to be portable at least between Unix-family platforms and\nWindows.\n\nA wall clock is a clock which measures the date and time according to\nsome external reference.\n\nExternal references may be reset, so this clock is not necessarily\nmonotonic, making it unsuitable for measuring elapsed time.\n\nIt is intended for reporting the current date and time for humans."
      },
      "package": 1
    },
    {
      "name": "types",
      "types": {
        "input-stream": 24,
        "output-stream": 25,
        "error": 26,
        "datetime": 27,
        "filesize": 28,
        "descriptor-type": 29,
        "descriptor-flags": 30,
        "path-flags": 31,
        "open-flags": 32,
        "link-count": 33,
        "descriptor-stat": 35,
        "new-timestamp": 36,
        "directory-entry": 37,
        "error-code": 38,
        "advice": 39,
        "metadata-hash-value": 40,
        "descriptor": 41,
        "directory-entry-stream": 42
      },
      "functions": {
        "[method]descriptor.advise": {
          "name": "[method]descriptor.advise",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            },
            {
              "name": "offset",
              "type": 28
            },
            {
              "name": "length",
              "type": 28
            },
            {
              "name": "advice",
              "type": 39
            }
          ],
          "result": 44,
          "docs": {
            "contents": "Provide file advisory information on a descriptor.\n\nThis is similar to `posix_fadvise` in POSIX."
          }
        },
        "[method]descriptor.append-via-stream": {
          "name": "[method]descriptor.append-via-stream",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            }
          ],
          "result": 46,
          "docs": {
            "contents": "Return a stream for appending to a file, if available.\n\nMay fail with an error-code describing why the file cannot be appended.\n\nNote: This allows using `write-stream`, which is similar to `write` with\n`O_APPEND` in in POSIX."
          }
        },
        "[method]descriptor.create-directory-at": {
          "name": "[method]descriptor.create-directory-at",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            },
            {
              "name": "path",
              "type": "string"
            }
          ],
          "result": 44,
          "docs": {
            "contents": "Create a directory.\n\nNote: This is similar to `mkdirat` in POSIX."
          }
        },
        "[method]descriptor.get-flags": {
          "name": "[method]descriptor.get-flags",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            }
          ],
          "result": 47,
          "docs": {
            "contents": "Get flags associated with a descriptor.\n\nNote: This returns similar flags to `fcntl(fd, F_GETFL)` in POSIX.\n\nNote: This returns the value that was the `fs_flags` value returned\nfrom `fdstat_get` in earlier versions of WASI."
          }
        },
        "[method]descriptor.get-type": {
          "name": "[method]descriptor.get-type",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            }
          ],
          "result": 48,
          "docs": {
            "contents": "Get the dynamic type of a descriptor.\n\nNote: This returns the same value as the `type` field of the `fd-stat`\nreturned by `stat`, `stat-at` and similar.\n\nNote: This returns similar flags to the `st_mode & S_IFMT` value provided\nby `fstat` in POSIX.\n\nNote: This returns the value that was the `fs_filetype` value returned\nfrom `fdstat_get` in earlier versions of WASI."
          }
        },
        "[method]descriptor.is-same-object": {
          "name": "[method]descriptor.is-same-object",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            },
            {
              "name": "other",
              "type": 43
            }
          ],
          "result": "bool",
          "docs": {
            "contents": "Test whether two descriptors refer to the same filesystem object.\n\nIn POSIX, this corresponds to testing whether the two descriptors have the\nsame device (`st_dev`) and inode (`st_ino` or `d_ino`) numbers.\nwasi-filesystem does not expose device and inode numbers, so this function\nmay be used instead."
          }
        },
        "[method]descriptor.link-at": {
          "name": "[method]descriptor.link-at",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            },
            {
              "name": "old-path-flags",
              "type": 31
            },
            {
              "name": "old-path",
              "type": "string"
            },
            {
              "name": "new-descriptor",
              "type": 43
            },
            {
              "name": "new-path",
              "type": "string"
            }
          ],
          "result": 44,
          "docs": {
            "contents": "Create a hard link.\n\nNote: This is similar to `linkat` in POSIX."
          }
        },
        "[method]descriptor.metadata-hash": {
          "name": "[method]descriptor.metadata-hash",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            }
          ],
          "result": 49,
          "docs": {
            "contents": "Return a hash of the metadata associated with a filesystem object referred\nto by a descriptor.\n\nThis returns a hash of the last-modification timestamp and file size, and\nmay also include the inode number, device number, birth timestamp, and\nother metadata fields that may change when the file is modified or\nreplaced. It may also include a secret value chosen by the\nimplementation and not otherwise exposed.\n\nImplementations are encourated to provide the following properties:\n\n- If the file is not modified or replaced, the computed hash value should\nusually not change.\n- If the object is modified or replaced, the computed hash value should\nusually change.\n- The inputs to the hash should not be easily computable from the\ncomputed hash.\n\nHowever, none of these is required."
          }
        },
        "[method]descriptor.metadata-hash-at": {
          "name": "[method]descriptor.metadata-hash-at",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            },
            {
              "name": "path-flags",
              "type": 31
            },
            {
              "name": "path",
              "type": "string"
            }
          ],
          "result": 49,
          "docs": {
            "contents": "Return a hash of the metadata associated with a filesystem object referred\nto by a directory descriptor and a relative path.\n\nThis performs the same hash computation as `metadata-hash`."
          }
        },
        "[method]descriptor.open-at": {
          "name": "[method]descriptor.open-at",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            },
            {
              "name": "path-flags",
              "type": 31
            },
            {
              "name": "path",
              "type": "string"
            },
            {
              "name": "open-flags",
              "type": 32
            },
            {
              "name": "flags",
              "type": 30
            }
          ],
          "result": 51,
          "docs": {
            "contents": "Open a file or directory.\n\nThe returned descriptor is not guaranteed to be the lowest-numbered\ndescriptor not currently open/ it is randomized to prevent applications\nfrom depending on making assumptions about indexes, since this is\nerror-prone in multi-threaded contexts. The returned descriptor is\nguaranteed to be less than 2**31.\n\nIf `flags` contains `descriptor-flags::mutate-directory`, and the base\ndescriptor doesn't have `descriptor-flags::mutate-directory` set,\n`open-at` fails with `error-code::read-only`.\n\nIf `flags` contains `write` or `mutate-directory`, or `open-flags`\ncontains `truncate` or `create`, and the base descriptor doesn't have\n`descriptor-flags::mutate-directory` set, `open-at` fails with\n`error-code::read-only`.\n\nNote: This is similar to `openat` in POSIX."
          }
        },
        "[method]descriptor.read": {
          "name": "[method]descriptor.read",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            },
            {
              "name": "length",
              "type": 28
            },
            {
              "name": "offset",
              "type": 28
            }
          ],
          "result": 54,
          "docs": {
            "contents": "Read from a descriptor, without using and updating the descriptor's offset.\n\nThis function returns a list of bytes containing the data that was\nread, along with a bool which, when true, indicates that the end of the\nfile was reached. The returned list will contain up to `length` bytes; it\nmay return fewer than requested, if the end of the file is reached or\nif the I/O operation is interrupted.\n\nIn the future, this may change to return a `stream<u8, error-code>`.\n\nNote: This is similar to `pread` in POSIX."
          }
        },
        "[method]descriptor.read-directory": {
          "name": "[method]descriptor.read-directory",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            }
          ],
          "result": 56,
          "docs": {
            "contents": "Read directory entries from a directory.\n\nOn filesystems where directories contain entries referring to themselves\nand their parents, often named `.` and `..` respectively, these entries\nare omitted.\n\nThis always returns a new stream which starts at the beginning of the\ndirectory. Multiple streams may be active on the same directory, and they\ndo not interfere with each other."
          }
        },
        "[method]descriptor.read-via-stream": {
          "name": "[method]descriptor.read-via-stream",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            },
            {
              "name": "offset",
              "type": 28
            }
          ],
          "result": 58,
          "docs": {
            "contents": "Return a stream for reading from a file, if available.\n\nMay fail with an error-code describing why the file cannot be read.\n\nMultiple read, write, and append streams may be active on the same open\nfile and they do not interfere with each other.\n\nNote: This allows using `read-stream`, which is similar to `read` in POSIX."
          }
        },
        "[method]descriptor.readlink-at": {
          "name": "[method]descriptor.readlink-at",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            },
            {
              "name": "path",
              "type": "string"
            }
          ],
          "result": 59,
          "docs": {
            "contents": "Read the contents of a symbolic link.\n\nIf the contents contain an absolute or rooted path in the underlying\nfilesystem, this function fails with `error-code::not-permitted`.\n\nNote: This is similar to `readlinkat` in POSIX."
          }
        },
        "[method]descriptor.remove-directory-at": {
          "name": "[method]descriptor.remove-directory-at",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            },
            {
              "name": "path",
              "type": "string"
            }
          ],
          "result": 44,
          "docs": {
            "contents": "Remove a directory.\n\nReturn `error-code::not-empty` if the directory is not empty.\n\nNote: This is similar to `unlinkat(fd, path, AT_REMOVEDIR)` in POSIX."
          }
        },
        "[method]descriptor.rename-at": {
          "name": "[method]descriptor.rename-at",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            },
            {
              "name": "old-path",
              "type": "string"
            },
            {
              "name": "new-descriptor",
              "type": 43
            },
            {
              "name": "new-path",
              "type": "string"
            }
          ],
          "result": 44,
          "docs": {
            "contents": "Rename a filesystem object.\n\nNote: This is similar to `renameat` in POSIX."
          }
        },
        "[method]descriptor.set-size": {
          "name": "[method]descriptor.set-size",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            },
            {
              "name": "size",
              "type": 28
            }
          ],
          "result": 44,
          "docs": {
            "contents": "Adjust the size of an open file. If this increases the file's size, the\nextra bytes are filled with zeros.\n\nNote: This was called `fd_filestat_set_size` in earlier versions of WASI."
          }
        },
        "[method]descriptor.set-times": {
          "name": "[method]descriptor.set-times",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            },
            {
              "name": "data-access-timestamp",
              "type": 36
            },
            {
              "name": "data-modification-timestamp",
              "type": 36
            }
          ],
          "result": 44,
          "docs": {
            "contents": "Adjust the timestamps of an open file or directory.\n\nNote: This is similar to `futimens` in POSIX.\n\nNote: This was called `fd_filestat_set_times` in earlier versions of WASI."
          }
        },
        "[method]descriptor.set-times-at": {
          "name": "[method]descriptor.set-times-at",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            },
            {
              "name": "path-flags",
              "type": 31
            },
            {
              "name": "path",
              "type": "string"
            },
            {
              "name": "data-access-timestamp",
              "type": 36
            },
            {
              "name": "data-modification-timestamp",
              "type": 36
            }
          ],
          "result": 44,
          "docs": {
            "contents": "Adjust the timestamps of a file or directory.\n\nNote: This is similar to `utimensat` in POSIX.\n\nNote: This was called `path_filestat_set_times` in earlier versions of\nWASI."
          }
        },
        "[method]descriptor.stat": {
          "name": "[method]descriptor.stat",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            }
          ],
          "result": 60,
          "docs": {
            "contents": "Return the attributes of an open file or directory.\n\nNote: This is similar to `fstat` in POSIX, except that it does not return\ndevice and inode information. For testing whether two descriptors refer to\nthe same underlying filesystem object, use `is-same-object`. To obtain\nadditional data that can be used do determine whether a file has been\nmodified, use `metadata-hash`.\n\nNote: This was called `fd_filestat_get` in earlier versions of WASI."
          }
        },
        "[method]descriptor.stat-at": {
          "name": "[method]descriptor.stat-at",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            },
            {
              "name": "path-flags",
              "type": 31
            },
            {
              "name": "path",
              "type": "string"
            }
          ],
          "result": 60,
          "docs": {
            "contents": "Return the attributes of a file or directory.\n\nNote: This is similar to `fstatat` in POSIX, except that it does not\nreturn device and inode information. See the `stat` description for a\ndiscussion of alternatives.\n\nNote: This was called `path_filestat_get` in earlier versions of WASI."
          }
        },
        "[method]descriptor.symlink-at": {
          "name": "[method]descriptor.symlink-at",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            },
            {
              "name": "old-path",
              "type": "string"
            },
            {
              "name": "new-path",
              "type": "string"
            }
          ],
          "result": 44,
          "docs": {
            "contents": "Create a symbolic link (also known as a \"symlink\").\n\nIf `old-path` starts with `/`, the function fails with\n`error-code::not-permitted`.\n\nNote: This is similar to `symlinkat` in POSIX."
          }
        },
        "[method]descriptor.sync": {
          "name": "[method]descriptor.sync",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            }
          ],
          "result": 44,
          "docs": {
            "contents": "Synchronize the data and metadata of a file to disk.\n\nThis function succeeds with no effect if the file descriptor is not\nopened for writing.\n\nNote: This is similar to `fsync` in POSIX."
          }
        },
        "[method]descriptor.sync-data": {
          "name": "[method]descriptor.sync-data",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            }
          ],
          "result": 44,
          "docs": {
            "contents": "Synchronize the data of a file to disk.\n\nThis function succeeds with no effect if the file descriptor is not\nopened for writing.\n\nNote: This is similar to `fdatasync` in POSIX."
          }
        },
        "[method]descriptor.unlink-file-at": {
          "name": "[method]descriptor.unlink-file-at",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            },
            {
              "name": "path",
              "type": "string"
            }
          ],
          "result": 44,
          "docs": {
            "contents": "Unlink a filesystem object that is not a directory.\n\nReturn `error-code::is-directory` if the path refers to a directory.\nNote: This is similar to `unlinkat(fd, path, 0)` in POSIX."
          }
        },
        "[method]descriptor.write": {
          "name": "[method]descriptor.write",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            },
            {
              "name": "buffer",
              "type": 52
            },
            {
              "name": "offset",
              "type": 28
            }
          ],
          "result": 61,
          "docs": {
            "contents": "Write to a descriptor, without using and updating the descriptor's offset.\n\nIt is valid to write past the end of a file; the file is extended to the\nextent of the write, with bytes between the previous end and the start of\nthe write set to zero.\n\nIn the future, this may change to take a `stream<u8, error-code>`.\n\nNote: This is similar to `pwrite` in POSIX."
          }
        },
        "[method]descriptor.write-via-stream": {
          "name": "[method]descriptor.write-via-stream",
          "kind": {
            "method": 41
          },
          "params": [
            {
              "name": "self",
              "type": 43
            },
            {
              "name": "offset",
              "type": 28
            }
          ],
          "result": 46,
          "docs": {
            "contents": "Return a stream for writing to a file, if available.\n\nMay fail with an error-code describing why the file cannot be written.\n\nNote: This allows using `write-stream`, which is similar to `write` in\nPOSIX."
          }
        },
        "[method]directory-entry-stream.read-directory-entry": {
          "name": "[method]directory-entry-stream.read-directory-entry",
          "kind": {
            "method": 42
          },
          "params": [
            {
              "name": "self",
              "type": 62
            }
          ],
          "result": 64,
          "docs": {
            "contents": "Read a single directory entry from a `directory-entry-stream`."
          }
        },
        "filesystem-error-code": {
          "name": "filesystem-error-code",
          "kind": "freestanding",
          "params": [
            {
              "name": "err",
              "type": 65
            }
          ],
          "result": 66,
          "docs": {
            "contents": "Attempts to extract a filesystem-related `error-code` from the stream\n`error` provided.\n\nStream operations which return `stream-error::last-operation-failed`\nhave a payload with more information about the operation that failed.\nThis payload can be passed through to this function to see if there's\nfilesystem-related information about the error to return.\n\nNote that this function is fallible because not all stream-related\nerrors are filesystem-related errors."
          }
        }
      },
      "docs": {
        "contents": "WASI filesystem is a filesystem API primarily intended to let users run WASI\nprograms that access their files on their existing filesystems, without\nsignificant overhead.\n\nIt is intended to be roughly portable between Unix-family platforms and\nWindows, though it does not hide many of the major differences.\n\nPaths are passed as interface-type `string`s, meaning they must consist of\na sequence of Unicode Scalar Values (USVs). Some filesystems may contain\npaths which are not accessible by this API.\n\nThe directory separator in WASI is always the forward-slash (`/`).\n\nAll paths in WASI are relative paths, and are interpreted relative to a\n`descriptor` referring to a base directory. If a `path` argument to any WASI\nfunction starts with `/`, or if any step of resolving a `path`, including\n`..` and symbolic link steps, reaches a directory outside of the base\ndirectory, or reaches a symlink to an absolute or rooted path in the\nunderlying filesystem, the function fails with `error-code::not-permitted`.\n\nFor more information about WASI path resolution and sandboxing, see\n[WASI filesystem path resolution].\n\n[WASI filesystem path resolution]: https://github.com/WebAssembly/wasi-filesystem/blob/main/path-resolution.md"
      },
      "package": 2
    },
    {
      "name": "preopens",
      "types": {
        "descriptor": 67
      },
      "functions": {
        "get-directories": {
          "name": "get-directories",
          "kind": "freestanding",
          "params": [],
          "result": 70,
          "docs": {
            "contents": "Return the set of preopened directories, and their path."
          }
        }
      },
      "package": 2
    },
    {
      "name": "network",
      "types": {
        "network": 71,
        "error-code": 72,
        "ip-address-family": 73,
        "ipv4-address": 74,
        "ipv6-address": 75,
        "ip-address": 76,
        "ipv4-socket-address": 77,
        "ipv6-socket-address": 78,
        "ip-socket-address": 79
      },
      "functions": {},
      "package": 3
    },
    {
      "name": "instance-network",
      "types": {
        "network": 80
      },
      "functions": {
        "instance-network": {
          "name": "instance-network",
          "kind": "freestanding",
          "params": [],
          "result": 157,
          "docs": {
            "contents": "Get a handle to the default network."
          }
        }
      },
      "docs": {
        "contents": "This interface provides a value-export of the default network handle.."
      },
      "package": 3
    },
    {
      "name": "ip-name-lookup",
      "types": {
        "pollable": 81,
        "network": 82,
        "error-code": 83,
        "ip-address": 84,
        "resolve-address-stream": 85
      },
      "functions": {
        "[method]resolve-address-stream.resolve-next-address": {
          "name": "[method]resolve-address-stream.resolve-next-address",
          "kind": {
            "method": 85
          },
          "params": [
            {
              "name": "self",
              "type": 86
            }
          ],
          "result": 88,
          "docs": {
            "contents": "Returns the next address from the resolver.\n\nThis function should be called multiple times. On each call, it will\nreturn the next address in connection order preference. If all\naddresses have been exhausted, this function returns `none`.\n\nThis function never returns IPv4-mapped IPv6 addresses.\n\n# Typical errors\n- `name-unresolvable`:          Name does not exist or has no suitable associated\nIP addresses. (EAI_NONAME, EAI_NODATA, EAI_ADDRFAMILY)\n- `temporary-resolver-failure`: A temporary failure in name resolution occurred.\n(EAI_AGAIN)\n- `permanent-resolver-failure`: A permanent failure in name resolution occurred.\n(EAI_FAIL)\n- `would-block`:                A result is not available yet. (EWOULDBLOCK, EAGAIN)"
          }
        },
        "[method]resolve-address-stream.subscribe": {
          "name": "[method]resolve-address-stream.subscribe",
          "kind": {
            "method": 85
          },
          "params": [
            {
              "name": "self",
              "type": 86
            }
          ],
          "result": 158,
          "docs": {
            "contents": "Create a `pollable` which will resolve once the stream is ready for I/O.\n\nNote: this function is here for WASI Preview2 only.\nIt's planned to be removed when `future` is natively supported in Preview3."
          }
        },
        "resolve-addresses": {
          "name": "resolve-addresses",
          "kind": "freestanding",
          "params": [
            {
              "name": "network",
              "type": 89
            },
            {
              "name": "name",
              "type": "string"
            }
          ],
          "result": 91,
          "docs": {
            "contents": "Resolve an internet host name to a list of IP addresses.\n\nUnicode domain names are automatically converted to ASCII using IDNA encoding.\nIf the input is an IP address string, the address is parsed and returned\nas-is without making any external requests.\n\nSee the wasi-socket proposal README.md for a comparison with getaddrinfo.\n\nThis function never blocks. It either immediately fails or immediately\nreturns successfully with a `resolve-address-stream` that can be used\nto (asynchronously) fetch the results.\n\n# Typical errors\n- `invalid-argument`: `name` is a syntactically invalid domain name or IP address.\n\n# References:\n- <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getaddrinfo.html>\n- <https://man7.org/linux/man-pages/man3/getaddrinfo.3.html>\n- <https://learn.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-getaddrinfo>\n- <https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&sektion=3>"
          }
        }
      },
      "package": 3
    },
    {
      "name": "tcp",
      "types": {
        "input-stream": 92,
        "output-stream": 93,
        "pollable": 94,
        "duration": 95,
        "network": 96,
        "error-code": 97,
        "ip-socket-address": 98,
        "ip-address-family": 99,
        "shutdown-type": 100,
        "tcp-socket": 101
      },
      "functions": {
        "[method]tcp-socket.accept": {
          "name": "[method]tcp-socket.accept",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            }
          ],
          "result": 107,
          "docs": {
            "contents": "Accept a new client socket.\n\nThe returned socket is bound and in the `connected` state. The following properties\nare inherited from the listener socket:\n- `address-family`\n- `keep-alive-enabled`\n- `keep-alive-idle-time`\n- `keep-alive-interval`\n- `keep-alive-count`\n- `hop-limit`\n- `receive-buffer-size`\n- `send-buffer-size`\n\nOn success, this function returns the newly accepted client socket along with\na pair of streams that can be used to read & write to the connection.\n\n# Typical errors\n- `invalid-state`:      Socket is not in the `listening` state. (EINVAL)\n- `would-block`:        No pending connections at the moment. (EWOULDBLOCK, EAGAIN)\n- `connection-aborted`: An incoming connection was pending, but was terminated\nby the client before this listener could accept it. (ECONNABORTED)\n- `new-socket-limit`:   The new socket resource could not be created because of\na system limit. (EMFILE, ENFILE)\n\n# References\n- <https://pubs.opengroup.org/onlinepubs/9699919799/functions/accept.html>\n- <https://man7.org/linux/man-pages/man2/accept.2.html>\n- <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-accept>\n- <https://man.freebsd.org/cgi/man.cgi?query=accept&sektion=2>"
          }
        },
        "[method]tcp-socket.address-family": {
          "name": "[method]tcp-socket.address-family",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            }
          ],
          "result": 99,
          "docs": {
            "contents": "Whether this is a IPv4 or IPv6 socket.\n\nEquivalent to the SO_DOMAIN socket option."
          }
        },
        "[method]tcp-socket.finish-bind": {
          "name": "[method]tcp-socket.finish-bind",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            }
          ],
          "result": 108
        },
        "[method]tcp-socket.finish-connect": {
          "name": "[method]tcp-socket.finish-connect",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            }
          ],
          "result": 110
        },
        "[method]tcp-socket.finish-listen": {
          "name": "[method]tcp-socket.finish-listen",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            }
          ],
          "result": 108
        },
        "[method]tcp-socket.hop-limit": {
          "name": "[method]tcp-socket.hop-limit",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            }
          ],
          "result": 111,
          "docs": {
            "contents": "Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.\n\nIf the provided value is 0, an `invalid-argument` error is returned.\n\n# Typical errors\n- `invalid-argument`:     (set) The TTL value must be 1 or higher."
          }
        },
        "[method]tcp-socket.is-listening": {
          "name": "[method]tcp-socket.is-listening",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            }
          ],
          "result": "bool",
          "docs": {
            "contents": "Whether the socket is in the `listening` state.\n\nEquivalent to the SO_ACCEPTCONN socket option."
          }
        },
        "[method]tcp-socket.keep-alive-count": {
          "name": "[method]tcp-socket.keep-alive-count",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            }
          ],
          "result": 112,
          "docs": {
            "contents": "The maximum amount of keepalive packets TCP should send before aborting the connection.\n\nIf the provided value is 0, an `invalid-argument` error is returned.\nAny other value will never cause an error, but it might be silently clamped and/or\nrounded.\nI.e. after setting a value, reading the same setting back may return a different\nvalue.\n\nEquivalent to the TCP_KEEPCNT socket option.\n\n# Typical errors\n- `invalid-argument`:     (set) The provided value was 0."
          }
        },
        "[method]tcp-socket.keep-alive-enabled": {
          "name": "[method]tcp-socket.keep-alive-enabled",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            }
          ],
          "result": 113,
          "docs": {
            "contents": "Enables or disables keepalive.\n\nThe keepalive behavior can be adjusted using:\n- `keep-alive-idle-time`\n- `keep-alive-interval`\n- `keep-alive-count`\nThese properties can be configured while `keep-alive-enabled` is false, but only\ncome into effect when `keep-alive-enabled` is true.\n\nEquivalent to the SO_KEEPALIVE socket option."
          }
        },
        "[method]tcp-socket.keep-alive-idle-time": {
          "name": "[method]tcp-socket.keep-alive-idle-time",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            }
          ],
          "result": 114,
          "docs": {
            "contents": "Amount of time the connection has to be idle before TCP starts sending keepalive\npackets.\n\nIf the provided value is 0, an `invalid-argument` error is returned.\nAny other value will never cause an error, but it might be silently clamped and/or\nrounded.\nI.e. after setting a value, reading the same setting back may return a different\nvalue.\n\nEquivalent to the TCP_KEEPIDLE socket option. (TCP_KEEPALIVE on MacOS)\n\n# Typical errors\n- `invalid-argument`:     (set) The provided value was 0."
          }
        },
        "[method]tcp-socket.keep-alive-interval": {
          "name": "[method]tcp-socket.keep-alive-interval",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            }
          ],
          "result": 114,
          "docs": {
            "contents": "The time between keepalive packets.\n\nIf the provided value is 0, an `invalid-argument` error is returned.\nAny other value will never cause an error, but it might be silently clamped and/or\nrounded.\nI.e. after setting a value, reading the same setting back may return a different\nvalue.\n\nEquivalent to the TCP_KEEPINTVL socket option.\n\n# Typical errors\n- `invalid-argument`:     (set) The provided value was 0."
          }
        },
        "[method]tcp-socket.local-address": {
          "name": "[method]tcp-socket.local-address",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            }
          ],
          "result": 115,
          "docs": {
            "contents": "Get the bound local address.\n\nPOSIX mentions:\n> If the socket has not been bound to a local name, the value\n> stored in the object pointed to by `address` is unspecified.\n\nWASI is stricter and requires `local-address` to return `invalid-state` when the\nsocket hasn't been bound yet.\n\n# Typical errors\n- `invalid-state`: The socket is not bound to any local address.\n\n# References\n- <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>\n- <https://man7.org/linux/man-pages/man2/getsockname.2.html>\n- <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>\n- <https://man.freebsd.org/cgi/man.cgi?getsockname>"
          }
        },
        "[method]tcp-socket.receive-buffer-size": {
          "name": "[method]tcp-socket.receive-buffer-size",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            }
          ],
          "result": 116,
          "docs": {
            "contents": "The kernel buffer space reserved for sends/receives on this socket.\n\nIf the provided value is 0, an `invalid-argument` error is returned.\nAny other value will never cause an error, but it might be silently clamped and/or\nrounded.\nI.e. after setting a value, reading the same setting back may return a different\nvalue.\n\nEquivalent to the SO_RCVBUF and SO_SNDBUF socket options.\n\n# Typical errors\n- `invalid-argument`:     (set) The provided value was 0."
          }
        },
        "[method]tcp-socket.remote-address": {
          "name": "[method]tcp-socket.remote-address",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            }
          ],
          "result": 115,
          "docs": {
            "contents": "Get the remote address.\n\n# Typical errors\n- `invalid-state`: The socket is not connected to a remote address. (ENOTCONN)\n\n# References\n- <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>\n- <https://man7.org/linux/man-pages/man2/getpeername.2.html>\n- <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>\n- <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>"
          }
        },
        "[method]tcp-socket.send-buffer-size": {
          "name": "[method]tcp-socket.send-buffer-size",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            }
          ],
          "result": 116
        },
        "[method]tcp-socket.set-hop-limit": {
          "name": "[method]tcp-socket.set-hop-limit",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            },
            {
              "name": "value",
              "type": "u8"
            }
          ],
          "result": 108
        },
        "[method]tcp-socket.set-keep-alive-count": {
          "name": "[method]tcp-socket.set-keep-alive-count",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            },
            {
              "name": "value",
              "type": "u32"
            }
          ],
          "result": 108
        },
        "[method]tcp-socket.set-keep-alive-enabled": {
          "name": "[method]tcp-socket.set-keep-alive-enabled",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            },
            {
              "name": "value",
              "type": "bool"
            }
          ],
          "result": 108
        },
        "[method]tcp-socket.set-keep-alive-idle-time": {
          "name": "[method]tcp-socket.set-keep-alive-idle-time",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            },
            {
              "name": "value",
              "type": 95
            }
          ],
          "result": 108
        },
        "[method]tcp-socket.set-keep-alive-interval": {
          "name": "[method]tcp-socket.set-keep-alive-interval",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            },
            {
              "name": "value",
              "type": 95
            }
          ],
          "result": 108
        },
        "[method]tcp-socket.set-listen-backlog-size": {
          "name": "[method]tcp-socket.set-listen-backlog-size",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            },
            {
              "name": "value",
              "type": "u64"
            }
          ],
          "result": 108,
          "docs": {
            "contents": "Hints the desired listen queue size. Implementations are free to ignore this.\n\nIf the provided value is 0, an `invalid-argument` error is returned.\nAny other value will never cause an error, but it might be silently clamped and/or\nrounded.\n\n# Typical errors\n- `not-supported`:        (set) The platform does not support changing the backlog\nsize after the initial listen.\n- `invalid-argument`:     (set) The provided value was 0.\n- `invalid-state`:        (set) The socket is in the `connect-in-progress` or\n`connected` state."
          }
        },
        "[method]tcp-socket.set-receive-buffer-size": {
          "name": "[method]tcp-socket.set-receive-buffer-size",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            },
            {
              "name": "value",
              "type": "u64"
            }
          ],
          "result": 108
        },
        "[method]tcp-socket.set-send-buffer-size": {
          "name": "[method]tcp-socket.set-send-buffer-size",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            },
            {
              "name": "value",
              "type": "u64"
            }
          ],
          "result": 108
        },
        "[method]tcp-socket.shutdown": {
          "name": "[method]tcp-socket.shutdown",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            },
            {
              "name": "shutdown-type",
              "type": 100
            }
          ],
          "result": 108,
          "docs": {
            "contents": "Initiate a graceful shutdown.\n\n- `receive`: The socket is not expecting to receive any data from\nthe peer. The `input-stream` associated with this socket will be\nclosed. Any data still in the receive queue at time of calling\nthis method will be discarded.\n- `send`: The socket has no more data to send to the peer. The `output-stream`\nassociated with this socket will be closed and a FIN packet will be sent.\n- `both`: Same effect as `receive` & `send` combined.\n\nThis function is idempotent. Shutting a down a direction more than once\nhas no effect and returns `ok`.\n\nThe shutdown function does not close (drop) the socket.\n\n# Typical errors\n- `invalid-state`: The socket is not in the `connected` state. (ENOTCONN)\n\n# References\n- <https://pubs.opengroup.org/onlinepubs/9699919799/functions/shutdown.html>\n- <https://man7.org/linux/man-pages/man2/shutdown.2.html>\n- <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-shutdown>\n- <https://man.freebsd.org/cgi/man.cgi?query=shutdown&sektion=2>"
          }
        },
        "[method]tcp-socket.start-bind": {
          "name": "[method]tcp-socket.start-bind",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            },
            {
              "name": "network",
              "type": 117
            },
            {
              "name": "local-address",
              "type": 98
            }
          ],
          "result": 108,
          "docs": {
            "contents": "Bind the socket to a specific network on the provided IP address and port.\n\nIf the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the\nimplementation to decide which\nnetwork interface(s) to bind to.\nIf the TCP/UDP port is zero, the socket will be bound to a random free port.\n\nBind can be attempted multiple times on the same socket, even with\ndifferent arguments on each iteration. But never concurrently and\nonly as long as the previous bind failed. Once a bind succeeds, the\nbinding can't be changed anymore.\n\n# Typical errors\n- `invalid-argument`:          The `local-address` has the wrong address family.\n(EAFNOSUPPORT, EFAULT on Windows)\n- `invalid-argument`:          `local-address` is not a unicast address. (EINVAL)\n- `invalid-argument`:          `local-address` is an IPv4-mapped IPv6 address.\n(EINVAL)\n- `invalid-state`:             The socket is already bound. (EINVAL)\n- `address-in-use`:            No ephemeral ports available. (EADDRINUSE, ENOBUFS\non Windows)\n- `address-in-use`:            Address is already in use. (EADDRINUSE)\n- `address-not-bindable`:      `local-address` is not an address that the `network`\ncan bind to. (EADDRNOTAVAIL)\n- `not-in-progress`:           A `bind` operation is not in progress.\n- `would-block`:               Can't finish the operation, it is still in progress.\n(EWOULDBLOCK, EAGAIN)\n\n# Implementors note\nWhen binding to a non-zero port, this bind operation shouldn't be affected by\nthe TIME_WAIT\nstate of a recently closed socket on the same local address. In practice this\nmeans that the SO_REUSEADDR\nsocket option should be set implicitly on all platforms, except on Windows where\nthis is the default behavior\nand SO_REUSEADDR performs something different entirely.\n\nUnlike in POSIX, in WASI the bind operation is async. This enables\ninteractive WASI hosts to inject permission prompts. Runtimes that\ndon't want to make use of this ability can simply call the native\n`bind` as part of either `start-bind` or `finish-bind`.\n\n# References\n- <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>\n- <https://man7.org/linux/man-pages/man2/bind.2.html>\n- <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>\n- <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>"
          }
        },
        "[method]tcp-socket.start-connect": {
          "name": "[method]tcp-socket.start-connect",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            },
            {
              "name": "network",
              "type": 117
            },
            {
              "name": "remote-address",
              "type": 98
            }
          ],
          "result": 108,
          "docs": {
            "contents": "Connect to a remote endpoint.\n\nOn success:\n- the socket is transitioned into the `connection` state.\n- a pair of streams is returned that can be used to read & write to the connection\n\nAfter a failed connection attempt, the socket will be in the `closed`\nstate and the only valid action left is to `drop` the socket. A single\nsocket can not be used to connect more than once.\n\n# Typical errors\n- `invalid-argument`:          The `remote-address` has the wrong address family.\n(EAFNOSUPPORT)\n- `invalid-argument`:          `remote-address` is not a unicast address. (EINVAL,\nENETUNREACH on Linux, EAFNOSUPPORT on MacOS)\n- `invalid-argument`:          `remote-address` is an IPv4-mapped IPv6 address.\n(EINVAL, EADDRNOTAVAIL on Illumos)\n- `invalid-argument`:          The IP address in `remote-address` is set to INADDR_ANY\n(`0.0.0.0` / `::`). (EADDRNOTAVAIL on Windows)\n- `invalid-argument`:          The port in `remote-address` is set to 0. (EADDRNOTAVAIL\non Windows)\n- `invalid-argument`:          The socket is already attached to a different network.\nThe `network` passed to `connect` must be identical to the one passed to `bind`.\n- `invalid-state`:             The socket is already in the `connected` state.\n(EISCONN)\n- `invalid-state`:             The socket is already in the `listening` state.\n(EOPNOTSUPP, EINVAL on Windows)\n- `timeout`:                   Connection timed out. (ETIMEDOUT)\n- `connection-refused`:        The connection was forcefully rejected. (ECONNREFUSED)\n- `connection-reset`:          The connection was reset. (ECONNRESET)\n- `connection-aborted`:        The connection was aborted. (ECONNABORTED)\n- `remote-unreachable`:        The remote address is not reachable. (EHOSTUNREACH,\nEHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)\n- `address-in-use`:            Tried to perform an implicit bind, but there were\nno ephemeral ports available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)\n- `not-in-progress`:           A connect operation is not in progress.\n- `would-block`:               Can't finish the operation, it is still in progress.\n(EWOULDBLOCK, EAGAIN)\n\n# Implementors note\nThe POSIX equivalent of `start-connect` is the regular `connect` syscall.\nBecause all WASI sockets are non-blocking this is expected to return\nEINPROGRESS, which should be translated to `ok()` in WASI.\n\nThe POSIX equivalent of `finish-connect` is a `poll` for event `POLLOUT`\nwith a timeout of 0 on the socket descriptor. Followed by a check for\nthe `SO_ERROR` socket option, in case the poll signaled readiness.\n\n# References\n- <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>\n- <https://man7.org/linux/man-pages/man2/connect.2.html>\n- <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>\n- <https://man.freebsd.org/cgi/man.cgi?connect>"
          }
        },
        "[method]tcp-socket.start-listen": {
          "name": "[method]tcp-socket.start-listen",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            }
          ],
          "result": 108,
          "docs": {
            "contents": "Start listening for new connections.\n\nTransitions the socket into the `listening` state.\n\nUnlike POSIX, the socket must already be explicitly bound.\n\n# Typical errors\n- `invalid-state`:             The socket is not bound to any local address. (EDESTADDRREQ)\n- `invalid-state`:             The socket is already in the `connected` state.\n(EISCONN, EINVAL on BSD)\n- `invalid-state`:             The socket is already in the `listening` state.\n- `address-in-use`:            Tried to perform an implicit bind, but there were\nno ephemeral ports available. (EADDRINUSE)\n- `not-in-progress`:           A listen operation is not in progress.\n- `would-block`:               Can't finish the operation, it is still in progress.\n(EWOULDBLOCK, EAGAIN)\n\n# Implementors note\nUnlike in POSIX, in WASI the listen operation is async. This enables\ninteractive WASI hosts to inject permission prompts. Runtimes that\ndon't want to make use of this ability can simply call the native\n`listen` as part of either `start-listen` or `finish-listen`.\n\n# References\n- <https://pubs.opengroup.org/onlinepubs/9699919799/functions/listen.html>\n- <https://man7.org/linux/man-pages/man2/listen.2.html>\n- <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-listen>\n- <https://man.freebsd.org/cgi/man.cgi?query=listen&sektion=2>"
          }
        },
        "[method]tcp-socket.subscribe": {
          "name": "[method]tcp-socket.subscribe",
          "kind": {
            "method": 101
          },
          "params": [
            {
              "name": "self",
              "type": 102
            }
          ],
          "result": 159,
          "docs": {
            "contents": "Create a `pollable` which can be used to poll for, or block on,\ncompletion of any of the asynchronous operations of this socket.\n\nWhen `finish-bind`, `finish-listen`, `finish-connect` or `accept`\nreturn `error(would-block)`, this pollable can be used to wait for\ntheir success or failure, after which the method can be retried.\n\nThe pollable is not limited to the async operation that happens to be\nin progress at the time of calling `subscribe` (if any). Theoretically,\n`subscribe` only has to be called once per socket and can then be\n(re)used for the remainder of the socket's lifetime.\n\nSee <https://github.com/WebAssembly/wasi-sockets/TcpSocketOperationalSemantics.md#Pollable-readiness>\nfor a more information.\n\nNote: this function is here for WASI Preview2 only.\nIt's planned to be removed when `future` is natively supported in Preview3."
          }
        }
      },
      "package": 3
    },
    {
      "name": "tcp-create-socket",
      "types": {
        "network": 118,
        "error-code": 119,
        "ip-address-family": 120,
        "tcp-socket": 121
      },
      "functions": {
        "create-tcp-socket": {
          "name": "create-tcp-socket",
          "kind": "freestanding",
          "params": [
            {
              "name": "address-family",
              "type": 120
            }
          ],
          "result": 123,
          "docs": {
            "contents": "Create a new TCP socket.\n\nSimilar to `socket(AF_INET or AF_INET6, SOCK_STREAM, IPPROTO_TCP)` in POSIX.\nOn IPv6 sockets, IPV6_V6ONLY is enabled by default and can't be configured otherwise.\n\nThis function does not require a network capability handle. This is considered\nto be safe because\nat time of creation, the socket is not bound to any `network` yet. Up to the moment\n`bind`/`connect`\nis called, the socket is effectively an in-memory configuration object, unable\nto communicate with the outside world.\n\nAll sockets are non-blocking. Use the wasi-poll interface to block on asynchronous\noperations.\n\n# Typical errors\n- `not-supported`:     The specified `address-family` is not supported. (EAFNOSUPPORT)\n- `new-socket-limit`:  The new socket resource could not be created because of\na system limit. (EMFILE, ENFILE)\n\n# References\n- <https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html>\n- <https://man7.org/linux/man-pages/man2/socket.2.html>\n- <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketw>\n- <https://man.freebsd.org/cgi/man.cgi?query=socket&sektion=2>"
          }
        }
      },
      "package": 3
    },
    {
      "name": "udp",
      "types": {
        "pollable": 124,
        "network": 125,
        "error-code": 126,
        "ip-socket-address": 127,
        "ip-address-family": 128,
        "incoming-datagram": 130,
        "outgoing-datagram": 132,
        "udp-socket": 133,
        "incoming-datagram-stream": 134,
        "outgoing-datagram-stream": 135
      },
      "functions": {
        "[method]udp-socket.address-family": {
          "name": "[method]udp-socket.address-family",
          "kind": {
            "method": 133
          },
          "params": [
            {
              "name": "self",
              "type": 136
            }
          ],
          "result": 128,
          "docs": {
            "contents": "Whether this is a IPv4 or IPv6 socket.\n\nEquivalent to the SO_DOMAIN socket option."
          }
        },
        "[method]udp-socket.finish-bind": {
          "name": "[method]udp-socket.finish-bind",
          "kind": {
            "method": 133
          },
          "params": [
            {
              "name": "self",
              "type": 136
            }
          ],
          "result": 137
        },
        "[method]udp-socket.local-address": {
          "name": "[method]udp-socket.local-address",
          "kind": {
            "method": 133
          },
          "params": [
            {
              "name": "self",
              "type": 136
            }
          ],
          "result": 138,
          "docs": {
            "contents": "Get the current bound address.\n\nPOSIX mentions:\n> If the socket has not been bound to a local name, the value\n> stored in the object pointed to by `address` is unspecified.\n\nWASI is stricter and requires `local-address` to return `invalid-state` when the\nsocket hasn't been bound yet.\n\n# Typical errors\n- `invalid-state`: The socket is not bound to any local address.\n\n# References\n- <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>\n- <https://man7.org/linux/man-pages/man2/getsockname.2.html>\n- <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>\n- <https://man.freebsd.org/cgi/man.cgi?getsockname>"
          }
        },
        "[method]udp-socket.receive-buffer-size": {
          "name": "[method]udp-socket.receive-buffer-size",
          "kind": {
            "method": 133
          },
          "params": [
            {
              "name": "self",
              "type": 136
            }
          ],
          "result": 139,
          "docs": {
            "contents": "The kernel buffer space reserved for sends/receives on this socket.\n\nIf the provided value is 0, an `invalid-argument` error is returned.\nAny other value will never cause an error, but it might be silently clamped and/or\nrounded.\nI.e. after setting a value, reading the same setting back may return a different\nvalue.\n\nEquivalent to the SO_RCVBUF and SO_SNDBUF socket options.\n\n# Typical errors\n- `invalid-argument`:     (set) The provided value was 0."
          }
        },
        "[method]udp-socket.remote-address": {
          "name": "[method]udp-socket.remote-address",
          "kind": {
            "method": 133
          },
          "params": [
            {
              "name": "self",
              "type": 136
            }
          ],
          "result": 138,
          "docs": {
            "contents": "Get the address the socket is currently streaming to.\n\n# Typical errors\n- `invalid-state`: The socket is not streaming to a specific remote address. (ENOTCONN)\n\n# References\n- <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>\n- <https://man7.org/linux/man-pages/man2/getpeername.2.html>\n- <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>\n- <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>"
          }
        },
        "[method]udp-socket.send-buffer-size": {
          "name": "[method]udp-socket.send-buffer-size",
          "kind": {
            "method": 133
          },
          "params": [
            {
              "name": "self",
              "type": 136
            }
          ],
          "result": 139
        },
        "[method]udp-socket.set-receive-buffer-size": {
          "name": "[method]udp-socket.set-receive-buffer-size",
          "kind": {
            "method": 133
          },
          "params": [
            {
              "name": "self",
              "type": 136
            },
            {
              "name": "value",
              "type": "u64"
            }
          ],
          "result": 137
        },
        "[method]udp-socket.set-send-buffer-size": {
          "name": "[method]udp-socket.set-send-buffer-size",
          "kind": {
            "method": 133
          },
          "params": [
            {
              "name": "self",
              "type": 136
            },
            {
              "name": "value",
              "type": "u64"
            }
          ],
          "result": 137
        },
        "[method]udp-socket.set-unicast-hop-limit": {
          "name": "[method]udp-socket.set-unicast-hop-limit",
          "kind": {
            "method": 133
          },
          "params": [
            {
              "name": "self",
              "type": 136
            },
            {
              "name": "value",
              "type": "u8"
            }
          ],
          "result": 137
        },
        "[method]udp-socket.start-bind": {
          "name": "[method]udp-socket.start-bind",
          "kind": {
            "method": 133
          },
          "params": [
            {
              "name": "self",
              "type": 136
            },
            {
              "name": "network",
              "type": 140
            },
            {
              "name": "local-address",
              "type": 127
            }
          ],
          "result": 137,
          "docs": {
            "contents": "Bind the socket to a specific network on the provided IP address and port.\n\nIf the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the\nimplementation to decide which\nnetwork interface(s) to bind to.\nIf the port is zero, the socket will be bound to a random free port.\n\n# Typical errors\n- `invalid-argument`:          The `local-address` has the wrong address family.\n(EAFNOSUPPORT, EFAULT on Windows)\n- `invalid-state`:             The socket is already bound. (EINVAL)\n- `address-in-use`:            No ephemeral ports available. (EADDRINUSE, ENOBUFS\non Windows)\n- `address-in-use`:            Address is already in use. (EADDRINUSE)\n- `address-not-bindable`:      `local-address` is not an address that the `network`\ncan bind to. (EADDRNOTAVAIL)\n- `not-in-progress`:           A `bind` operation is not in progress.\n- `would-block`:               Can't finish the operation, it is still in progress.\n(EWOULDBLOCK, EAGAIN)\n\n# Implementors note\nUnlike in POSIX, in WASI the bind operation is async. This enables\ninteractive WASI hosts to inject permission prompts. Runtimes that\ndon't want to make use of this ability can simply call the native\n`bind` as part of either `start-bind` or `finish-bind`.\n\n# References\n- <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>\n- <https://man7.org/linux/man-pages/man2/bind.2.html>\n- <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>\n- <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>"
          }
        },
        "[method]udp-socket.stream": {
          "name": "[method]udp-socket.stream",
          "kind": {
            "method": 133
          },
          "params": [
            {
              "name": "self",
              "type": 136
            },
            {
              "name": "remote-address",
              "type": 131
            }
          ],
          "result": 144,
          "docs": {
            "contents": "Set up inbound & outbound communication channels, optionally to a specific peer.\n\nThis function only changes the local socket configuration and does not generate\nany network traffic.\nOn success, the `remote-address` of the socket is updated. The `local-address`\nmay be updated as well,\nbased on the best network path to `remote-address`.\n\nWhen a `remote-address` is provided, the returned streams are limited to communicating\nwith that specific peer:\n- `send` can only be used to send to this destination.\n- `receive` will only return datagrams sent from the provided `remote-address`.\n\nThis method may be called multiple times on the same socket to change its association,\nbut\nonly the most recently returned pair of streams will be operational. Implementations\nmay trap if\nthe streams returned by a previous invocation haven't been dropped yet before\ncalling `stream` again.\n\nThe POSIX equivalent in pseudo-code is:\n```text\nif (was previously connected) {\nconnect(s, AF_UNSPEC)\n}\nif (remote_address is Some) {\nconnect(s, remote_address)\n}\n```\n\nUnlike in POSIX, the socket must already be explicitly bound.\n\n# Typical errors\n- `invalid-argument`:          The `remote-address` has the wrong address family.\n(EAFNOSUPPORT)\n- `invalid-argument`:          The IP address in `remote-address` is set to INADDR_ANY\n(`0.0.0.0` / `::`). (EDESTADDRREQ, EADDRNOTAVAIL)\n- `invalid-argument`:          The port in `remote-address` is set to 0. (EDESTADDRREQ,\nEADDRNOTAVAIL)\n- `invalid-state`:             The socket is not bound.\n- `address-in-use`:            Tried to perform an implicit bind, but there were\nno ephemeral ports available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)\n- `remote-unreachable`:        The remote address is not reachable. (ECONNRESET,\nENETRESET, EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)\n- `connection-refused`:        The connection was refused. (ECONNREFUSED)\n\n# References\n- <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>\n- <https://man7.org/linux/man-pages/man2/connect.2.html>\n- <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>\n- <https://man.freebsd.org/cgi/man.cgi?connect>"
          }
        },
        "[method]udp-socket.subscribe": {
          "name": "[method]udp-socket.subscribe",
          "kind": {
            "method": 133
          },
          "params": [
            {
              "name": "self",
              "type": 136
            }
          ],
          "result": 160,
          "docs": {
            "contents": "Create a `pollable` which will resolve once the socket is ready for I/O.\n\nNote: this function is here for WASI Preview2 only.\nIt's planned to be removed when `future` is natively supported in Preview3."
          }
        },
        "[method]udp-socket.unicast-hop-limit": {
          "name": "[method]udp-socket.unicast-hop-limit",
          "kind": {
            "method": 133
          },
          "params": [
            {
              "name": "self",
              "type": 136
            }
          ],
          "result": 145,
          "docs": {
            "contents": "Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.\n\nIf the provided value is 0, an `invalid-argument` error is returned.\n\n# Typical errors\n- `invalid-argument`:     (set) The TTL value must be 1 or higher."
          }
        },
        "[method]incoming-datagram-stream.receive": {
          "name": "[method]incoming-datagram-stream.receive",
          "kind": {
            "method": 134
          },
          "params": [
            {
              "name": "self",
              "type": 146
            },
            {
              "name": "max-results",
              "type": "u64"
            }
          ],
          "result": 148,
          "docs": {
            "contents": "Receive messages on the socket.\n\nThis function attempts to receive up to `max-results` datagrams on the socket\nwithout blocking.\nThe returned list may contain fewer elements than requested, but never more.\n\nThis function returns successfully with an empty list when either:\n- `max-results` is 0, or:\n- `max-results` is greater than 0, but no results are immediately available.\nThis function never returns `error(would-block)`.\n\n# Typical errors\n- `remote-unreachable`: The remote address is not reachable. (ECONNRESET, ENETRESET\non Windows, EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)\n- `connection-refused`: The connection was refused. (ECONNREFUSED)\n\n# References\n- <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvfrom.html>\n- <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvmsg.html>\n- <https://man7.org/linux/man-pages/man2/recv.2.html>\n- <https://man7.org/linux/man-pages/man2/recvmmsg.2.html>\n- <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recv>\n- <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recvfrom>\n- <https://learn.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms741687(v=vs.85)>\n- <https://man.freebsd.org/cgi/man.cgi?query=recv&sektion=2>"
          }
        },
        "[method]incoming-datagram-stream.subscribe": {
          "name": "[method]incoming-datagram-stream.subscribe",
          "kind": {
            "method": 134
          },
          "params": [
            {
              "name": "self",
              "type": 146
            }
          ],
          "result": 160,
          "docs": {
            "contents": "Create a `pollable` which will resolve once the stream is ready to receive again.\n\nNote: this function is here for WASI Preview2 only.\nIt's planned to be removed when `future` is natively supported in Preview3."
          }
        },
        "[method]outgoing-datagram-stream.check-send": {
          "name": "[method]outgoing-datagram-stream.check-send",
          "kind": {
            "method": 135
          },
          "params": [
            {
              "name": "self",
              "type": 149
            }
          ],
          "result": 139,
          "docs": {
            "contents": "Check readiness for sending. This function never blocks.\n\nReturns the number of datagrams permitted for the next call to `send`,\nor an error. Calling `send` with more datagrams than this function has\npermitted will trap.\n\nWhen this function returns ok(0), the `subscribe` pollable will\nbecome ready when this function will report at least ok(1), or an\nerror.\n\nNever returns `would-block`."
          }
        },
        "[method]outgoing-datagram-stream.send": {
          "name": "[method]outgoing-datagram-stream.send",
          "kind": {
            "method": 135
          },
          "params": [
            {
              "name": "self",
              "type": 149
            },
            {
              "name": "datagrams",
              "type": 150
            }
          ],
          "result": 139,
          "docs": {
            "contents": "Send messages on the socket.\n\nThis function attempts to send all provided `datagrams` on the socket without\nblocking and\nreturns how many messages were actually sent (or queued for sending). This function\nnever\nreturns `error(would-block)`. If none of the datagrams were able to be sent, `ok(0)`\nis returned.\n\nThis function semantically behaves the same as iterating the `datagrams` list\nand sequentially\nsending each individual datagram until either the end of the list has been reached\nor the first error occurred.\nIf at least one datagram has been sent successfully, this function never returns\nan error.\n\nIf the input list is empty, the function returns `ok(0)`.\n\nEach call to `send` must be permitted by a preceding `check-send`. Implementations\nmust trap if\neither `check-send` was not called or `datagrams` contains more items than `check-send`\npermitted.\n\n# Typical errors\n- `invalid-argument`:        The `remote-address` has the wrong address family.\n(EAFNOSUPPORT)\n- `invalid-argument`:        The IP address in `remote-address` is set to INADDR_ANY\n(`0.0.0.0` / `::`). (EDESTADDRREQ, EADDRNOTAVAIL)\n- `invalid-argument`:        The port in `remote-address` is set to 0. (EDESTADDRREQ,\nEADDRNOTAVAIL)\n- `invalid-argument`:        The socket is in \"connected\" mode and `remote-address`\nis `some` value that does not match the address passed to `stream`. (EISCONN)\n- `invalid-argument`:        The socket is not \"connected\" and no value for `remote-address`\nwas provided. (EDESTADDRREQ)\n- `remote-unreachable`:      The remote address is not reachable. (ECONNRESET,\nENETRESET on Windows, EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)\n- `connection-refused`:      The connection was refused. (ECONNREFUSED)\n- `datagram-too-large`:      The datagram is too large. (EMSGSIZE)\n\n# References\n- <https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendto.html>\n- <https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendmsg.html>\n- <https://man7.org/linux/man-pages/man2/send.2.html>\n- <https://man7.org/linux/man-pages/man2/sendmmsg.2.html>\n- <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send>\n- <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-sendto>\n- <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasendmsg>\n- <https://man.freebsd.org/cgi/man.cgi?query=send&sektion=2>"
          }
        },
        "[method]outgoing-datagram-stream.subscribe": {
          "name": "[method]outgoing-datagram-stream.subscribe",
          "kind": {
            "method": 135
          },
          "params": [
            {
              "name": "self",
              "type": 149
            }
          ],
          "result": 160,
          "docs": {
            "contents": "Create a `pollable` which will resolve once the stream is ready to send again.\n\nNote: this function is here for WASI Preview2 only.\nIt's planned to be removed when `future` is natively supported in Preview3."
          }
        }
      },
      "package": 3
    },
    {
      "name": "udp-create-socket",
      "types": {
        "network": 151,
        "error-code": 152,
        "ip-address-family": 153,
        "udp-socket": 154
      },
      "functions": {
        "create-udp-socket": {
          "name": "create-udp-socket",
          "kind": "freestanding",
          "params": [
            {
              "name": "address-family",
              "type": 153
            }
          ],
          "result": 156,
          "docs": {
            "contents": "Create a new UDP socket.\n\nSimilar to `socket(AF_INET or AF_INET6, SOCK_DGRAM, IPPROTO_UDP)` in POSIX.\nOn IPv6 sockets, IPV6_V6ONLY is enabled by default and can't be configured otherwise.\n\nThis function does not require a network capability handle. This is considered\nto be safe because\nat time of creation, the socket is not bound to any `network` yet. Up to the moment\n`bind` is called,\nthe socket is effectively an in-memory configuration object, unable to communicate\nwith the outside world.\n\nAll sockets are non-blocking. Use the wasi-poll interface to block on asynchronous\noperations.\n\n# Typical errors\n- `not-supported`:     The specified `address-family` is not supported. (EAFNOSUPPORT)\n- `new-socket-limit`:  The new socket resource could not be created because of\na system limit. (EMFILE, ENFILE)\n\n# References:\n- <https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html>\n- <https://man7.org/linux/man-pages/man2/socket.2.html>\n- <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketw>\n- <https://man.freebsd.org/cgi/man.cgi?query=socket&sektion=2>"
          }
        }
      },
      "package": 3
    },
    {
      "name": "insecure-seed",
      "types": {},
      "functions": {
        "insecure-seed": {
          "name": "insecure-seed",
          "kind": "freestanding",
          "params": [],
          "result": 161,
          "docs": {
            "contents": "Return a 128-bit value that may contain a pseudo-random value.\n\nThe returned value is not required to be computed from a CSPRNG, and may\neven be entirely deterministic. Host implementations are encouraged to\nprovide pseudo-random values to any program exposed to\nattacker-controlled content, to enable DoS protection built into many\nlanguages' hash-map implementations.\n\nThis function is intended to only be called once, by a source language\nto initialize Denial Of Service (DoS) protection in its hash-map\nimplementation.\n\n# Expected future evolution\n\nThis will likely be changed to a value import, to prevent it from being\ncalled multiple times and potentially used for purposes other than DoS\nprotection."
          }
        }
      },
      "docs": {
        "contents": "The insecure-seed interface for seeding hash-map DoS resistance.\n\nIt is intended to be portable at least between Unix-family platforms and\nWindows."
      },
      "package": 4
    },
    {
      "name": "insecure",
      "types": {},
      "functions": {
        "get-insecure-random-bytes": {
          "name": "get-insecure-random-bytes",
          "kind": "freestanding",
          "params": [
            {
              "name": "len",
              "type": "u64"
            }
          ],
          "result": 162,
          "docs": {
            "contents": "Return `len` insecure pseudo-random bytes.\n\nThis function is not cryptographically secure. Do not use it for\nanything related to security.\n\nThere are no requirements on the values of the returned bytes, however\nimplementations are encouraged to return evenly distributed values with\na long period."
          }
        },
        "get-insecure-random-u64": {
          "name": "get-insecure-random-u64",
          "kind": "freestanding",
          "params": [],
          "result": "u64",
          "docs": {
            "contents": "Return an insecure pseudo-random `u64` value.\n\nThis function returns the same type of pseudo-random data as\n`get-insecure-random-bytes`, represented as a `u64`."
          }
        }
      },
      "docs": {
        "contents": "The insecure interface for insecure pseudo-random numbers.\n\nIt is intended to be portable at least between Unix-family platforms and\nWindows."
      },
      "package": 4
    },
    {
      "name": "random",
      "types": {},
      "functions": {
        "get-random-bytes": {
          "name": "get-random-bytes",
          "kind": "freestanding",
          "params": [
            {
              "name": "len",
              "type": "u64"
            }
          ],
          "result": 162,
          "docs": {
            "contents": "Return `len` cryptographically-secure random or pseudo-random bytes.\n\nThis function must produce data at least as cryptographically secure and\nfast as an adequately seeded cryptographically-secure pseudo-random\nnumber generator (CSPRNG). It must not block, from the perspective of\nthe calling program, under any circumstances, including on the first\nrequest and on requests for numbers of bytes. The returned data must\nalways be unpredictable.\n\nThis function must always return fresh data. Deterministic environments\nmust omit this function, rather than implementing it with deterministic\ndata."
          }
        },
        "get-random-u64": {
          "name": "get-random-u64",
          "kind": "freestanding",
          "params": [],
          "result": "u64",
          "docs": {
            "contents": "Return a cryptographically-secure random or pseudo-random `u64` value.\n\nThis function returns the same type of data as `get-random-bytes`,\nrepresented as a `u64`."
          }
        }
      },
      "docs": {
        "contents": "WASI Random is a random data API.\n\nIt is intended to be portable at least between Unix-family platforms and\nWindows."
      },
      "package": 4
    },
    {
      "name": "environment",
      "types": {},
      "functions": {
        "get-environment": {
          "name": "get-environment",
          "kind": "freestanding",
          "params": [],
          "result": 164,
          "docs": {
            "contents": "Get the POSIX-style environment variables.\n\nEach environment variable is provided as a pair of string variable names\nand string value.\n\nMorally, these are a value import, but until value imports are available\nin the component model, this import function should return the same\nvalues each time it is called."
          }
        },
        "get-arguments": {
          "name": "get-arguments",
          "kind": "freestanding",
          "params": [],
          "result": 165,
          "docs": {
            "contents": "Get the POSIX-style arguments to the program."
          }
        },
        "initial-cwd": {
          "name": "initial-cwd",
          "kind": "freestanding",
          "params": [],
          "result": 166,
          "docs": {
            "contents": "Return a path that programs should use as their initial current working\ndirectory, interpreting `.` as shorthand for this."
          }
        }
      },
      "package": 5
    },
    {
      "name": "exit",
      "types": {},
      "functions": {
        "exit": {
          "name": "exit",
          "kind": "freestanding",
          "params": [
            {
              "name": "status",
              "type": 167
            }
          ],
          "docs": {
            "contents": "Exit the current instance and any linked instances."
          }
        }
      },
      "package": 5
    },
    {
      "name": "run",
      "types": {},
      "functions": {
        "run": {
          "name": "run",
          "kind": "freestanding",
          "params": [],
          "result": 167,
          "docs": {
            "contents": "Run the program."
          }
        }
      },
      "package": 5
    },
    {
      "name": "stdin",
      "types": {
        "input-stream": 168
      },
      "functions": {
        "get-stdin": {
          "name": "get-stdin",
          "kind": "freestanding",
          "params": [],
          "result": 182
        }
      },
      "package": 5
    },
    {
      "name": "stdout",
      "types": {
        "output-stream": 169
      },
      "functions": {
        "get-stdout": {
          "name": "get-stdout",
          "kind": "freestanding",
          "params": [],
          "result": 183
        }
      },
      "package": 5
    },
    {
      "name": "stderr",
      "types": {
        "output-stream": 170
      },
      "functions": {
        "get-stderr": {
          "name": "get-stderr",
          "kind": "freestanding",
          "params": [],
          "result": 184
        }
      },
      "package": 5
    },
    {
      "name": "terminal-input",
      "types": {
        "terminal-input": 171
      },
      "functions": {},
      "docs": {
        "contents": "Terminal input.\n\nIn the future, this may include functions for disabling echoing,\ndisabling input buffering so that keyboard events are sent through\nimmediately, querying supported features, and so on."
      },
      "package": 5
    },
    {
      "name": "terminal-output",
      "types": {
        "terminal-output": 172
      },
      "functions": {},
      "docs": {
        "contents": "Terminal output.\n\nIn the future, this may include functions for querying the terminal\nsize, being notified of terminal size changes, querying supported\nfeatures, and so on."
      },
      "package": 5
    },
    {
      "name": "terminal-stdin",
      "types": {
        "terminal-input": 173
      },
      "functions": {
        "get-terminal-stdin": {
          "name": "get-terminal-stdin",
          "kind": "freestanding",
          "params": [],
          "result": 175,
          "docs": {
            "contents": "If stdin is connected to a terminal, return a `terminal-input` handle\nallowing further interaction with it."
          }
        }
      },
      "docs": {
        "contents": "An interface providing an optional `terminal-input` for stdin as a\nlink-time authority."
      },
      "package": 5
    },
    {
      "name": "terminal-stdout",
      "types": {
        "terminal-output": 176
      },
      "functions": {
        "get-terminal-stdout": {
          "name": "get-terminal-stdout",
          "kind": "freestanding",
          "params": [],
          "result": 178,
          "docs": {
            "contents": "If stdout is connected to a terminal, return a `terminal-output` handle\nallowing further interaction with it."
          }
        }
      },
      "docs": {
        "contents": "An interface providing an optional `terminal-output` for stdout as a\nlink-time authority."
      },
      "package": 5
    },
    {
      "name": "terminal-stderr",
      "types": {
        "terminal-output": 179
      },
      "functions": {
        "get-terminal-stderr": {
          "name": "get-terminal-stderr",
          "kind": "freestanding",
          "params": [],
          "result": 181,
          "docs": {
            "contents": "If stderr is connected to a terminal, return a `terminal-output` handle\nallowing further interaction with it."
          }
        }
      },
      "docs": {
        "contents": "An interface providing an optional `terminal-output` for stderr as a\nlink-time authority."
      },
      "package": 5
    }
  ],
  "types": [
    {
      "name": "error",
      "kind": "resource",
      "owner": {
        "interface": 0
      },
      "docs": {
        "contents": "A resource which represents some error information.\n\nThe only method provided by this resource is `to-debug-string`,\nwhich provides some human-readable information about the error.\n\nIn the `wasi:io` package, this resource is returned through the\n`wasi:io/streams/stream-error` type.\n\nTo provide more specific error information, other interfaces may\nprovide functions to further \"downcast\" this error into more specific\nerror information. For example, `error`s returned in streams derived\nfrom filesystem types to be described using the filesystem's own\nerror-code type, using the function\n`wasi:filesystem/types/filesystem-error-code`, which takes a parameter\n`borrow<error>` and returns\n`option<wasi:filesystem/types/error-code>`.\n\nThe set of functions which can \"downcast\" an `error` into a more\nconcrete type is open."
      }
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "borrow": 0
        }
      },
      "owner": null
    },
    {
      "name": "pollable",
      "kind": "resource",
      "owner": {
        "interface": 1
      },
      "docs": {
        "contents": "`pollable` represents a single I/O event which may be ready, or not."
      }
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "borrow": 2
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "list": 3
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "list": "u32"
      },
      "owner": null
    },
    {
      "name": "error",
      "kind": {
        "type": 0
      },
      "owner": {
        "interface": 2
      }
    },
    {
      "name": "pollable",
      "kind": {
        "type": 2
      },
      "owner": {
        "interface": 2
      }
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 6
        }
      },
      "owner": null
    },
    {
      "name": "stream-error",
      "kind": {
        "variant": {
          "cases": [
            {
              "name": "last-operation-failed",
              "type": 8,
              "docs": {
                "contents": "The last operation (a write or flush) failed before completion.\n\nMore information is available in the `error` payload."
              }
            },
            {
              "name": "closed",
              "type": null,
              "docs": {
                "contents": "The stream is closed: no more input will be accepted by the\nstream. A closed output-stream will return this error on all\nfuture operations."
              }
            }
          ]
        }
      },
      "owner": {
        "interface": 2
      },
      "docs": {
        "contents": "An error for input-stream and output-stream operations."
      }
    },
    {
      "name": "input-stream",
      "kind": "resource",
      "owner": {
        "interface": 2
      },
      "docs": {
        "contents": "An input bytestream.\n\n`input-stream`s are *non-blocking* to the extent practical on underlying\nplatforms. I/O operations always return promptly; if fewer bytes are\npromptly available than requested, they return the number of bytes promptly\navailable, which could even be zero. To wait for data to be available,\nuse the `subscribe` function to obtain a `pollable` which can be polled\nfor using `wasi:io/poll`."
      }
    },
    {
      "name": "output-stream",
      "kind": "resource",
      "owner": {
        "interface": 2
      },
      "docs": {
        "contents": "An output bytestream.\n\n`output-stream`s are *non-blocking* to the extent practical on\nunderlying platforms. Except where specified otherwise, I/O operations also\nalways return promptly, after the number of bytes that can be written\npromptly, which could even be zero. To wait for the stream to be ready to\naccept data, the `subscribe` function to obtain a `pollable` which can be\npolled for using `wasi:io/poll`."
      }
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "borrow": 10
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "list": "u8"
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": 13,
          "err": 9
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": "u64",
          "err": 9
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "borrow": 11
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": null,
          "err": 9
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 7
        }
      },
      "owner": null
    },
    {
      "name": "pollable",
      "kind": {
        "type": 2
      },
      "owner": {
        "interface": 3
      }
    },
    {
      "name": "instant",
      "kind": {
        "type": "u64"
      },
      "owner": {
        "interface": 3
      },
      "docs": {
        "contents": "An instant in time, in nanoseconds. An instant is relative to an\nunspecified initial value, and can only be compared to instances from\nthe same monotonic-clock."
      }
    },
    {
      "name": "duration",
      "kind": {
        "type": "u64"
      },
      "owner": {
        "interface": 3
      },
      "docs": {
        "contents": "A duration of time, in nanoseconds."
      }
    },
    {
      "name": "datetime",
      "kind": {
        "record": {
          "fields": [
            {
              "name": "seconds",
              "type": "u64"
            },
            {
              "name": "nanoseconds",
              "type": "u32"
            }
          ]
        }
      },
      "owner": {
        "interface": 4
      },
      "docs": {
        "contents": "A time and date in seconds plus nanoseconds."
      }
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 19
        }
      },
      "owner": null
    },
    {
      "name": "input-stream",
      "kind": {
        "type": 10
      },
      "owner": {
        "interface": 5
      }
    },
    {
      "name": "output-stream",
      "kind": {
        "type": 11
      },
      "owner": {
        "interface": 5
      }
    },
    {
      "name": "error",
      "kind": {
        "type": 6
      },
      "owner": {
        "interface": 5
      }
    },
    {
      "name": "datetime",
      "kind": {
        "type": 22
      },
      "owner": {
        "interface": 5
      }
    },
    {
      "name": "filesize",
      "kind": {
        "type": "u64"
      },
      "owner": {
        "interface": 5
      },
      "docs": {
        "contents": "File size or length of a region within a file."
      }
    },
    {
      "name": "descriptor-type",
      "kind": {
        "enum": {
          "cases": [
            {
              "name": "unknown",
              "docs": {
                "contents": "The type of the descriptor or file is unknown or is different from\nany of the other types specified."
              }
            },
            {
              "name": "block-device",
              "docs": {
                "contents": "The descriptor refers to a block device inode."
              }
            },
            {
              "name": "character-device",
              "docs": {
                "contents": "The descriptor refers to a character device inode."
              }
            },
            {
              "name": "directory",
              "docs": {
                "contents": "The descriptor refers to a directory inode."
              }
            },
            {
              "name": "fifo",
              "docs": {
                "contents": "The descriptor refers to a named pipe."
              }
            },
            {
              "name": "symbolic-link",
              "docs": {
                "contents": "The file refers to a symbolic link inode."
              }
            },
            {
              "name": "regular-file",
              "docs": {
                "contents": "The descriptor refers to a regular file inode."
              }
            },
            {
              "name": "socket",
              "docs": {
                "contents": "The descriptor refers to a socket."
              }
            }
          ]
        }
      },
      "owner": {
        "interface": 5
      },
      "docs": {
        "contents": "The type of a filesystem object referenced by a descriptor.\n\nNote: This was called `filetype` in earlier versions of WASI."
      }
    },
    {
      "name": "descriptor-flags",
      "kind": {
        "flags": {
          "flags": [
            {
              "name": "read",
              "docs": {
                "contents": "Read mode: Data can be read."
              }
            },
            {
              "name": "write",
              "docs": {
                "contents": "Write mode: Data can be written to."
              }
            },
            {
              "name": "file-integrity-sync",
              "docs": {
                "contents": "Request that writes be performed according to synchronized I/O file\nintegrity completion. The data stored in the file and the file's\nmetadata are synchronized. This is similar to `O_SYNC` in POSIX.\n\nThe precise semantics of this operation have not yet been defined for\nWASI. At this time, it should be interpreted as a request, and not a\nrequirement."
              }
            },
            {
              "name": "data-integrity-sync",
              "docs": {
                "contents": "Request that writes be performed according to synchronized I/O data\nintegrity completion. Only the data stored in the file is\nsynchronized. This is similar to `O_DSYNC` in POSIX.\n\nThe precise semantics of this operation have not yet been defined for\nWASI. At this time, it should be interpreted as a request, and not a\nrequirement."
              }
            },
            {
              "name": "requested-write-sync",
              "docs": {
                "contents": "Requests that reads be performed at the same level of integrety\nrequested for writes. This is similar to `O_RSYNC` in POSIX.\n\nThe precise semantics of this operation have not yet been defined for\nWASI. At this time, it should be interpreted as a request, and not a\nrequirement."
              }
            },
            {
              "name": "mutate-directory",
              "docs": {
                "contents": "Mutating directories mode: Directory contents may be mutated.\n\nWhen this flag is unset on a descriptor, operations using the\ndescriptor which would create, rename, delete, modify the data or\nmetadata of filesystem objects, or obtain another handle which\nwould permit any of those, shall fail with `error-code::read-only` if\nthey would otherwise succeed.\n\nThis may only be set on directories."
              }
            }
          ]
        }
      },
      "owner": {
        "interface": 5
      },
      "docs": {
        "contents": "Descriptor flags.\n\nNote: This was called `fdflags` in earlier versions of WASI."
      }
    },
    {
      "name": "path-flags",
      "kind": {
        "flags": {
          "flags": [
            {
              "name": "symlink-follow",
              "docs": {
                "contents": "As long as the resolved path corresponds to a symbolic link, it is\nexpanded."
              }
            }
          ]
        }
      },
      "owner": {
        "interface": 5
      },
      "docs": {
        "contents": "Flags determining the method of how paths are resolved."
      }
    },
    {
      "name": "open-flags",
      "kind": {
        "flags": {
          "flags": [
            {
              "name": "create",
              "docs": {
                "contents": "Create file if it does not exist, similar to `O_CREAT` in POSIX."
              }
            },
            {
              "name": "directory",
              "docs": {
                "contents": "Fail if not a directory, similar to `O_DIRECTORY` in POSIX."
              }
            },
            {
              "name": "exclusive",
              "docs": {
                "contents": "Fail if file already exists, similar to `O_EXCL` in POSIX."
              }
            },
            {
              "name": "truncate",
              "docs": {
                "contents": "Truncate file to size 0, similar to `O_TRUNC` in POSIX."
              }
            }
          ]
        }
      },
      "owner": {
        "interface": 5
      },
      "docs": {
        "contents": "Open flags used by `open-at`."
      }
    },
    {
      "name": "link-count",
      "kind": {
        "type": "u64"
      },
      "owner": {
        "interface": 5
      },
      "docs": {
        "contents": "Number of hard links to an inode."
      }
    },
    {
      "name": null,
      "kind": {
        "option": 27
      },
      "owner": null
    },
    {
      "name": "descriptor-stat",
      "kind": {
        "record": {
          "fields": [
            {
              "name": "type",
              "type": 29,
              "docs": {
                "contents": "File type."
              }
            },
            {
              "name": "link-count",
              "type": 33,
              "docs": {
                "contents": "Number of hard links to the file."
              }
            },
            {
              "name": "size",
              "type": 28,
              "docs": {
                "contents": "For regular files, the file size in bytes. For symbolic links, the\nlength in bytes of the pathname contained in the symbolic link."
              }
            },
            {
              "name": "data-access-timestamp",
              "type": 34,
              "docs": {
                "contents": "Last data access timestamp.\n\nIf the `option` is none, the platform doesn't maintain an access\ntimestamp for this file."
              }
            },
            {
              "name": "data-modification-timestamp",
              "type": 34,
              "docs": {
                "contents": "Last data modification timestamp.\n\nIf the `option` is none, the platform doesn't maintain a\nmodification timestamp for this file."
              }
            },
            {
              "name": "status-change-timestamp",
              "type": 34,
              "docs": {
                "contents": "Last file status-change timestamp.\n\nIf the `option` is none, the platform doesn't maintain a\nstatus-change timestamp for this file."
              }
            }
          ]
        }
      },
      "owner": {
        "interface": 5
      },
      "docs": {
        "contents": "File attributes.\n\nNote: This was called `filestat` in earlier versions of WASI."
      }
    },
    {
      "name": "new-timestamp",
      "kind": {
        "variant": {
          "cases": [
            {
              "name": "no-change",
              "type": null,
              "docs": {
                "contents": "Leave the timestamp set to its previous value."
              }
            },
            {
              "name": "now",
              "type": null,
              "docs": {
                "contents": "Set the timestamp to the current time of the system clock associated\nwith the filesystem."
              }
            },
            {
              "name": "timestamp",
              "type": 27,
              "docs": {
                "contents": "Set the timestamp to the given value."
              }
            }
          ]
        }
      },
      "owner": {
        "interface": 5
      },
      "docs": {
        "contents": "When setting a timestamp, this gives the value to set it to."
      }
    },
    {
      "name": "directory-entry",
      "kind": {
        "record": {
          "fields": [
            {
              "name": "type",
              "type": 29,
              "docs": {
                "contents": "The type of the file referred to by this directory entry."
              }
            },
            {
              "name": "name",
              "type": "string",
              "docs": {
                "contents": "The name of the object."
              }
            }
          ]
        }
      },
      "owner": {
        "interface": 5
      },
      "docs": {
        "contents": "A directory entry."
      }
    },
    {
      "name": "error-code",
      "kind": {
        "enum": {
          "cases": [
            {
              "name": "access",
              "docs": {
                "contents": "Permission denied, similar to `EACCES` in POSIX."
              }
            },
            {
              "name": "would-block",
              "docs": {
                "contents": "Resource unavailable, or operation would block, similar to `EAGAIN` and `EWOULDBLOCK`\nin POSIX."
              }
            },
            {
              "name": "already",
              "docs": {
                "contents": "Connection already in progress, similar to `EALREADY` in POSIX."
              }
            },
            {
              "name": "bad-descriptor",
              "docs": {
                "contents": "Bad descriptor, similar to `EBADF` in POSIX."
              }
            },
            {
              "name": "busy",
              "docs": {
                "contents": "Device or resource busy, similar to `EBUSY` in POSIX."
              }
            },
            {
              "name": "deadlock",
              "docs": {
                "contents": "Resource deadlock would occur, similar to `EDEADLK` in POSIX."
              }
            },
            {
              "name": "quota",
              "docs": {
                "contents": "Storage quota exceeded, similar to `EDQUOT` in POSIX."
              }
            },
            {
              "name": "exist",
              "docs": {
                "contents": "File exists, similar to `EEXIST` in POSIX."
              }
            },
            {
              "name": "file-too-large",
              "docs": {
                "contents": "File too large, similar to `EFBIG` in POSIX."
              }
            },
            {
              "name": "illegal-byte-sequence",
              "docs": {
                "contents": "Illegal byte sequence, similar to `EILSEQ` in POSIX."
              }
            },
            {
              "name": "in-progress",
              "docs": {
                "contents": "Operation in progress, similar to `EINPROGRESS` in POSIX."
              }
            },
            {
              "name": "interrupted",
              "docs": {
                "contents": "Interrupted function, similar to `EINTR` in POSIX."
              }
            },
            {
              "name": "invalid",
              "docs": {
                "contents": "Invalid argument, similar to `EINVAL` in POSIX."
              }
            },
            {
              "name": "io",
              "docs": {
                "contents": "I/O error, similar to `EIO` in POSIX."
              }
            },
            {
              "name": "is-directory",
              "docs": {
                "contents": "Is a directory, similar to `EISDIR` in POSIX."
              }
            },
            {
              "name": "loop",
              "docs": {
                "contents": "Too many levels of symbolic links, similar to `ELOOP` in POSIX."
              }
            },
            {
              "name": "too-many-links",
              "docs": {
                "contents": "Too many links, similar to `EMLINK` in POSIX."
              }
            },
            {
              "name": "message-size",
              "docs": {
                "contents": "Message too large, similar to `EMSGSIZE` in POSIX."
              }
            },
            {
              "name": "name-too-long",
              "docs": {
                "contents": "Filename too long, similar to `ENAMETOOLONG` in POSIX."
              }
            },
            {
              "name": "no-device",
              "docs": {
                "contents": "No such device, similar to `ENODEV` in POSIX."
              }
            },
            {
              "name": "no-entry",
              "docs": {
                "contents": "No such file or directory, similar to `ENOENT` in POSIX."
              }
            },
            {
              "name": "no-lock",
              "docs": {
                "contents": "No locks available, similar to `ENOLCK` in POSIX."
              }
            },
            {
              "name": "insufficient-memory",
              "docs": {
                "contents": "Not enough space, similar to `ENOMEM` in POSIX."
              }
            },
            {
              "name": "insufficient-space",
              "docs": {
                "contents": "No space left on device, similar to `ENOSPC` in POSIX."
              }
            },
            {
              "name": "not-directory",
              "docs": {
                "contents": "Not a directory or a symbolic link to a directory, similar to `ENOTDIR` in POSIX."
              }
            },
            {
              "name": "not-empty",
              "docs": {
                "contents": "Directory not empty, similar to `ENOTEMPTY` in POSIX."
              }
            },
            {
              "name": "not-recoverable",
              "docs": {
                "contents": "State not recoverable, similar to `ENOTRECOVERABLE` in POSIX."
              }
            },
            {
              "name": "unsupported",
              "docs": {
                "contents": "Not supported, similar to `ENOTSUP` and `ENOSYS` in POSIX."
              }
            },
            {
              "name": "no-tty",
              "docs": {
                "contents": "Inappropriate I/O control operation, similar to `ENOTTY` in POSIX."
              }
            },
            {
              "name": "no-such-device",
              "docs": {
                "contents": "No such device or address, similar to `ENXIO` in POSIX."
              }
            },
            {
              "name": "overflow",
              "docs": {
                "contents": "Value too large to be stored in data type, similar to `EOVERFLOW` in POSIX."
              }
            },
            {
              "name": "not-permitted",
              "docs": {
                "contents": "Operation not permitted, similar to `EPERM` in POSIX."
              }
            },
            {
              "name": "pipe",
              "docs": {
                "contents": "Broken pipe, similar to `EPIPE` in POSIX."
              }
            },
            {
              "name": "read-only",
              "docs": {
                "contents": "Read-only file system, similar to `EROFS` in POSIX."
              }
            },
            {
              "name": "invalid-seek",
              "docs": {
                "contents": "Invalid seek, similar to `ESPIPE` in POSIX."
              }
            },
            {
              "name": "text-file-busy",
              "docs": {
                "contents": "Text file busy, similar to `ETXTBSY` in POSIX."
              }
            },
            {
              "name": "cross-device",
              "docs": {
                "contents": "Cross-device link, similar to `EXDEV` in POSIX."
              }
            }
          ]
        }
      },
      "owner": {
        "interface": 5
      },
      "docs": {
        "contents": "Error codes returned by functions, similar to `errno` in POSIX.\nNot all of these error codes are returned by the functions provided by this\nAPI; some are used in higher-level library layers, and others are provided\nmerely for alignment with POSIX."
      }
    },
    {
      "name": "advice",
      "kind": {
        "enum": {
          "cases": [
            {
              "name": "normal",
              "docs": {
                "contents": "The application has no advice to give on its behavior with respect\nto the specified data."
              }
            },
            {
              "name": "sequential",
              "docs": {
                "contents": "The application expects to access the specified data sequentially\nfrom lower offsets to higher offsets."
              }
            },
            {
              "name": "random",
              "docs": {
                "contents": "The application expects to access the specified data in a random\norder."
              }
            },
            {
              "name": "will-need",
              "docs": {
                "contents": "The application expects to access the specified data in the near\nfuture."
              }
            },
            {
              "name": "dont-need",
              "docs": {
                "contents": "The application expects that it will not access the specified data\nin the near future."
              }
            },
            {
              "name": "no-reuse",
              "docs": {
                "contents": "The application expects to access the specified data once and then\nnot reuse it thereafter."
              }
            }
          ]
        }
      },
      "owner": {
        "interface": 5
      },
      "docs": {
        "contents": "File or memory access pattern advisory information."
      }
    },
    {
      "name": "metadata-hash-value",
      "kind": {
        "record": {
          "fields": [
            {
              "name": "lower",
              "type": "u64",
              "docs": {
                "contents": "64 bits of a 128-bit hash value."
              }
            },
            {
              "name": "upper",
              "type": "u64",
              "docs": {
                "contents": "Another 64 bits of a 128-bit hash value."
              }
            }
          ]
        }
      },
      "owner": {
        "interface": 5
      },
      "docs": {
        "contents": "A 128-bit hash value, split into parts because wasm doesn't have a\n128-bit integer type."
      }
    },
    {
      "name": "descriptor",
      "kind": "resource",
      "owner": {
        "interface": 5
      },
      "docs": {
        "contents": "A descriptor is a reference to a filesystem object, which may be a file,\ndirectory, named pipe, special file, or other object on which filesystem\ncalls may be made."
      }
    },
    {
      "name": "directory-entry-stream",
      "kind": "resource",
      "owner": {
        "interface": 5
      },
      "docs": {
        "contents": "A stream of directory entries."
      }
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "borrow": 41
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": null,
          "err": 38
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 25
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": 45,
          "err": 38
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": 30,
          "err": 38
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": 29,
          "err": 38
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": 40,
          "err": 38
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 41
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": 50,
          "err": 38
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "list": "u8"
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "tuple": {
          "types": [
            52,
            "bool"
          ]
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": 53,
          "err": 38
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 42
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": 55,
          "err": 38
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 24
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": 57,
          "err": 38
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": "string",
          "err": 38
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": 35,
          "err": 38
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": 28,
          "err": 38
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "borrow": 42
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "option": 37
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": 63,
          "err": 38
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "borrow": 26
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "option": 38
      },
      "owner": null
    },
    {
      "name": "descriptor",
      "kind": {
        "type": 41
      },
      "owner": {
        "interface": 6
      }
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 67
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "tuple": {
          "types": [
            68,
            "string"
          ]
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "list": 69
      },
      "owner": null
    },
    {
      "name": "network",
      "kind": "resource",
      "owner": {
        "interface": 7
      },
      "docs": {
        "contents": "An opaque resource that represents access to (a subset of) the network.\nThis enables context-based security for networking.\nThere is no need for this to map 1:1 to a physical network interface."
      }
    },
    {
      "name": "error-code",
      "kind": {
        "enum": {
          "cases": [
            {
              "name": "unknown",
              "docs": {
                "contents": "Unknown error"
              }
            },
            {
              "name": "access-denied",
              "docs": {
                "contents": "Access denied.\n\nPOSIX equivalent: EACCES, EPERM"
              }
            },
            {
              "name": "not-supported",
              "docs": {
                "contents": "The operation is not supported.\n\nPOSIX equivalent: EOPNOTSUPP"
              }
            },
            {
              "name": "invalid-argument",
              "docs": {
                "contents": "One of the arguments is invalid.\n\nPOSIX equivalent: EINVAL"
              }
            },
            {
              "name": "out-of-memory",
              "docs": {
                "contents": "Not enough memory to complete the operation.\n\nPOSIX equivalent: ENOMEM, ENOBUFS, EAI_MEMORY"
              }
            },
            {
              "name": "timeout",
              "docs": {
                "contents": "The operation timed out before it could finish completely."
              }
            },
            {
              "name": "concurrency-conflict",
              "docs": {
                "contents": "This operation is incompatible with another asynchronous operation that is already\nin progress.\n\nPOSIX equivalent: EALREADY"
              }
            },
            {
              "name": "not-in-progress",
              "docs": {
                "contents": "Trying to finish an asynchronous operation that:\n- has not been started yet, or:\n- was already finished by a previous `finish-*` call.\n\nNote: this is scheduled to be removed when `future`s are natively supported."
              }
            },
            {
              "name": "would-block",
              "docs": {
                "contents": "The operation has been aborted because it could not be completed immediately.\n\nNote: this is scheduled to be removed when `future`s are natively supported."
              }
            },
            {
              "name": "invalid-state",
              "docs": {
                "contents": "The operation is not valid in the socket's current state."
              }
            },
            {
              "name": "new-socket-limit",
              "docs": {
                "contents": "A new socket resource could not be created because of a system limit."
              }
            },
            {
              "name": "address-not-bindable",
              "docs": {
                "contents": "A bind operation failed because the provided address is not an address that the\n`network` can bind to."
              }
            },
            {
              "name": "address-in-use",
              "docs": {
                "contents": "A bind operation failed because the provided address is already in use or because\nthere are no ephemeral ports available."
              }
            },
            {
              "name": "remote-unreachable",
              "docs": {
                "contents": "The remote address is not reachable"
              }
            },
            {
              "name": "connection-refused",
              "docs": {
                "contents": "The TCP connection was forcefully rejected"
              }
            },
            {
              "name": "connection-reset",
              "docs": {
                "contents": "The TCP connection was reset."
              }
            },
            {
              "name": "connection-aborted",
              "docs": {
                "contents": "A TCP connection was aborted."
              }
            },
            {
              "name": "datagram-too-large",
              "docs": {
                "contents": "The size of a datagram sent to a UDP socket exceeded the maximum\nsupported size."
              }
            },
            {
              "name": "name-unresolvable",
              "docs": {
                "contents": "Name does not exist or has no suitable associated IP addresses."
              }
            },
            {
              "name": "temporary-resolver-failure",
              "docs": {
                "contents": "A temporary failure in name resolution occurred."
              }
            },
            {
              "name": "permanent-resolver-failure",
              "docs": {
                "contents": "A permanent failure in name resolution occurred."
              }
            }
          ]
        }
      },
      "owner": {
        "interface": 7
      },
      "docs": {
        "contents": "Error codes.\n\nIn theory, every API can return any error code.\nIn practice, API's typically only return the errors documented per API\ncombined with a couple of errors that are always possible:\n- `unknown`\n- `access-denied`\n- `not-supported`\n- `out-of-memory`\n- `concurrency-conflict`\n\nSee each individual API for what the POSIX equivalents are. They sometimes differ\nper API."
      }
    },
    {
      "name": "ip-address-family",
      "kind": {
        "enum": {
          "cases": [
            {
              "name": "ipv4",
              "docs": {
                "contents": "Similar to `AF_INET` in POSIX."
              }
            },
            {
              "name": "ipv6",
              "docs": {
                "contents": "Similar to `AF_INET6` in POSIX."
              }
            }
          ]
        }
      },
      "owner": {
        "interface": 7
      }
    },
    {
      "name": "ipv4-address",
      "kind": {
        "tuple": {
          "types": [
            "u8",
            "u8",
            "u8",
            "u8"
          ]
        }
      },
      "owner": {
        "interface": 7
      }
    },
    {
      "name": "ipv6-address",
      "kind": {
        "tuple": {
          "types": [
            "u16",
            "u16",
            "u16",
            "u16",
            "u16",
            "u16",
            "u16",
            "u16"
          ]
        }
      },
      "owner": {
        "interface": 7
      }
    },
    {
      "name": "ip-address",
      "kind": {
        "variant": {
          "cases": [
            {
              "name": "ipv4",
              "type": 74
            },
            {
              "name": "ipv6",
              "type": 75
            }
          ]
        }
      },
      "owner": {
        "interface": 7
      }
    },
    {
      "name": "ipv4-socket-address",
      "kind": {
        "record": {
          "fields": [
            {
              "name": "port",
              "type": "u16",
              "docs": {
                "contents": "sin_port"
              }
            },
            {
              "name": "address",
              "type": 74,
              "docs": {
                "contents": "sin_addr"
              }
            }
          ]
        }
      },
      "owner": {
        "interface": 7
      }
    },
    {
      "name": "ipv6-socket-address",
      "kind": {
        "record": {
          "fields": [
            {
              "name": "port",
              "type": "u16",
              "docs": {
                "contents": "sin6_port"
              }
            },
            {
              "name": "flow-info",
              "type": "u32",
              "docs": {
                "contents": "sin6_flowinfo"
              }
            },
            {
              "name": "address",
              "type": 75,
              "docs": {
                "contents": "sin6_addr"
              }
            },
            {
              "name": "scope-id",
              "type": "u32",
              "docs": {
                "contents": "sin6_scope_id"
              }
            }
          ]
        }
      },
      "owner": {
        "interface": 7
      }
    },
    {
      "name": "ip-socket-address",
      "kind": {
        "variant": {
          "cases": [
            {
              "name": "ipv4",
              "type": 77
            },
            {
              "name": "ipv6",
              "type": 78
            }
          ]
        }
      },
      "owner": {
        "interface": 7
      }
    },
    {
      "name": "network",
      "kind": {
        "type": 71
      },
      "owner": {
        "interface": 8
      }
    },
    {
      "name": "pollable",
      "kind": {
        "type": 2
      },
      "owner": {
        "interface": 9
      }
    },
    {
      "name": "network",
      "kind": {
        "type": 71
      },
      "owner": {
        "interface": 9
      }
    },
    {
      "name": "error-code",
      "kind": {
        "type": 72
      },
      "owner": {
        "interface": 9
      }
    },
    {
      "name": "ip-address",
      "kind": {
        "type": 76
      },
      "owner": {
        "interface": 9
      }
    },
    {
      "name": "resolve-address-stream",
      "kind": "resource",
      "owner": {
        "interface": 9
      }
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "borrow": 85
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "option": 84
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": 87,
          "err": 83
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "borrow": 82
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 85
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": 90,
          "err": 83
        }
      },
      "owner": null
    },
    {
      "name": "input-stream",
      "kind": {
        "type": 10
      },
      "owner": {
        "interface": 10
      }
    },
    {
      "name": "output-stream",
      "kind": {
        "type": 11
      },
      "owner": {
        "interface": 10
      }
    },
    {
      "name": "pollable",
      "kind": {
        "type": 2
      },
      "owner": {
        "interface": 10
      }
    },
    {
      "name": "duration",
      "kind": {
        "type": 21
      },
      "owner": {
        "interface": 10
      }
    },
    {
      "name": "network",
      "kind": {
        "type": 71
      },
      "owner": {
        "interface": 10
      }
    },
    {
      "name": "error-code",
      "kind": {
        "type": 72
      },
      "owner": {
        "interface": 10
      }
    },
    {
      "name": "ip-socket-address",
      "kind": {
        "type": 79
      },
      "owner": {
        "interface": 10
      }
    },
    {
      "name": "ip-address-family",
      "kind": {
        "type": 73
      },
      "owner": {
        "interface": 10
      }
    },
    {
      "name": "shutdown-type",
      "kind": {
        "enum": {
          "cases": [
            {
              "name": "receive",
              "docs": {
                "contents": "Similar to `SHUT_RD` in POSIX."
              }
            },
            {
              "name": "send",
              "docs": {
                "contents": "Similar to `SHUT_WR` in POSIX."
              }
            },
            {
              "name": "both",
              "docs": {
                "contents": "Similar to `SHUT_RDWR` in POSIX."
              }
            }
          ]
        }
      },
      "owner": {
        "interface": 10
      }
    },
    {
      "name": "tcp-socket",
      "kind": "resource",
      "owner": {
        "interface": 10
      },
      "docs": {
        "contents": "A TCP socket resource.\n\nThe socket can be in one of the following states:\n- `unbound`\n- `bind-in-progress`\n- `bound` (See note below)\n- `listen-in-progress`\n- `listening`\n- `connect-in-progress`\n- `connected`\n- `closed`\nSee <https://github.com/WebAssembly/wasi-sockets/TcpSocketOperationalSemantics.md>\nfor a more information.\n\nNote: Except where explicitly mentioned, whenever this documentation uses\nthe term \"bound\" without backticks it actually means: in the `bound` state *or\nhigher*.\n(i.e. `bound`, `listen-in-progress`, `listening`, `connect-in-progress` or `connected`)\n\nIn addition to the general error codes documented on the\n`network::error-code` type, TCP socket methods may always return\n`error(invalid-state)` when in the `closed` state."
      }
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "borrow": 101
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 101
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 92
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 93
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "tuple": {
          "types": [
            103,
            104,
            105
          ]
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": 106,
          "err": 97
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": null,
          "err": 97
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "tuple": {
          "types": [
            104,
            105
          ]
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": 109,
          "err": 97
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": "u8",
          "err": 97
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": "u32",
          "err": 97
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": "bool",
          "err": 97
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": 95,
          "err": 97
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": 98,
          "err": 97
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": "u64",
          "err": 97
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "borrow": 96
        }
      },
      "owner": null
    },
    {
      "name": "network",
      "kind": {
        "type": 71
      },
      "owner": {
        "interface": 11
      }
    },
    {
      "name": "error-code",
      "kind": {
        "type": 72
      },
      "owner": {
        "interface": 11
      }
    },
    {
      "name": "ip-address-family",
      "kind": {
        "type": 73
      },
      "owner": {
        "interface": 11
      }
    },
    {
      "name": "tcp-socket",
      "kind": {
        "type": 101
      },
      "owner": {
        "interface": 11
      }
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 121
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": 122,
          "err": 119
        }
      },
      "owner": null
    },
    {
      "name": "pollable",
      "kind": {
        "type": 2
      },
      "owner": {
        "interface": 12
      }
    },
    {
      "name": "network",
      "kind": {
        "type": 71
      },
      "owner": {
        "interface": 12
      }
    },
    {
      "name": "error-code",
      "kind": {
        "type": 72
      },
      "owner": {
        "interface": 12
      }
    },
    {
      "name": "ip-socket-address",
      "kind": {
        "type": 79
      },
      "owner": {
        "interface": 12
      }
    },
    {
      "name": "ip-address-family",
      "kind": {
        "type": 73
      },
      "owner": {
        "interface": 12
      }
    },
    {
      "name": null,
      "kind": {
        "list": "u8"
      },
      "owner": null
    },
    {
      "name": "incoming-datagram",
      "kind": {
        "record": {
          "fields": [
            {
              "name": "data",
              "type": 129,
              "docs": {
                "contents": "The payload.\n\nTheoretical max size: ~64 KiB. In practice, typically less than 1500 bytes."
              }
            },
            {
              "name": "remote-address",
              "type": 127,
              "docs": {
                "contents": "The source address.\n\nThis field is guaranteed to match the remote address the stream was initialized\nwith, if any.\n\nEquivalent to the `src_addr` out parameter of `recvfrom`."
              }
            }
          ]
        }
      },
      "owner": {
        "interface": 12
      },
      "docs": {
        "contents": "A received datagram."
      }
    },
    {
      "name": null,
      "kind": {
        "option": 127
      },
      "owner": null
    },
    {
      "name": "outgoing-datagram",
      "kind": {
        "record": {
          "fields": [
            {
              "name": "data",
              "type": 129,
              "docs": {
                "contents": "The payload."
              }
            },
            {
              "name": "remote-address",
              "type": 131,
              "docs": {
                "contents": "The destination address.\n\nThe requirements on this field depend on how the stream was initialized:\n- with a remote address: this field must be None or match the stream's remote\naddress exactly.\n- without a remote address: this field is required.\n\nIf this value is None, the send operation is equivalent to `send` in POSIX. Otherwise\nit is equivalent to `sendto`."
              }
            }
          ]
        }
      },
      "owner": {
        "interface": 12
      },
      "docs": {
        "contents": "A datagram to be sent out."
      }
    },
    {
      "name": "udp-socket",
      "kind": "resource",
      "owner": {
        "interface": 12
      },
      "docs": {
        "contents": "A UDP socket handle."
      }
    },
    {
      "name": "incoming-datagram-stream",
      "kind": "resource",
      "owner": {
        "interface": 12
      }
    },
    {
      "name": "outgoing-datagram-stream",
      "kind": "resource",
      "owner": {
        "interface": 12
      }
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "borrow": 133
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": null,
          "err": 126
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": 127,
          "err": 126
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": "u64",
          "err": 126
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "borrow": 125
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 134
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 135
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "tuple": {
          "types": [
            141,
            142
          ]
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": 143,
          "err": 126
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": "u8",
          "err": 126
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "borrow": 134
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "list": 130
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": 147,
          "err": 126
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "borrow": 135
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "list": 132
      },
      "owner": null
    },
    {
      "name": "network",
      "kind": {
        "type": 71
      },
      "owner": {
        "interface": 13
      }
    },
    {
      "name": "error-code",
      "kind": {
        "type": 72
      },
      "owner": {
        "interface": 13
      }
    },
    {
      "name": "ip-address-family",
      "kind": {
        "type": 73
      },
      "owner": {
        "interface": 13
      }
    },
    {
      "name": "udp-socket",
      "kind": {
        "type": 133
      },
      "owner": {
        "interface": 13
      }
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 154
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": 155,
          "err": 152
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 80
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 81
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 94
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 124
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "tuple": {
          "types": [
            "u64",
            "u64"
          ]
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "list": "u8"
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "tuple": {
          "types": [
            "string",
            "string"
          ]
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "list": 163
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "list": "string"
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "option": "string"
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "result": {
          "ok": null,
          "err": null
        }
      },
      "owner": null
    },
    {
      "name": "input-stream",
      "kind": {
        "type": 10
      },
      "owner": {
        "interface": 20
      }
    },
    {
      "name": "output-stream",
      "kind": {
        "type": 11
      },
      "owner": {
        "interface": 21
      }
    },
    {
      "name": "output-stream",
      "kind": {
        "type": 11
      },
      "owner": {
        "interface": 22
      }
    },
    {
      "name": "terminal-input",
      "kind": "resource",
      "owner": {
        "interface": 23
      },
      "docs": {
        "contents": "The input side of a terminal."
      }
    },
    {
      "name": "terminal-output",
      "kind": "resource",
      "owner": {
        "interface": 24
      },
      "docs": {
        "contents": "The output side of a terminal."
      }
    },
    {
      "name": "terminal-input",
      "kind": {
        "type": 171
      },
      "owner": {
        "interface": 25
      }
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 173
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "option": 174
      },
      "owner": null
    },
    {
      "name": "terminal-output",
      "kind": {
        "type": 172
      },
      "owner": {
        "interface": 26
      }
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 176
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "option": 177
      },
      "owner": null
    },
    {
      "name": "terminal-output",
      "kind": {
        "type": 172
      },
      "owner": {
        "interface": 27
      }
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 179
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "option": 180
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 168
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 169
        }
      },
      "owner": null
    },
    {
      "name": null,
      "kind": {
        "handle": {
          "own": 170
        }
      },
      "owner": null
    }
  ],
  "packages": [
    {
      "name": "wasi:io@0.2.0",
      "interfaces": {
        "error": 0,
        "poll": 1,
        "streams": 2
      },
      "worlds": {}
    },
    {
      "name": "wasi:clocks@0.2.0",
      "interfaces": {
        "monotonic-clock": 3,
        "wall-clock": 4
      },
      "worlds": {}
    },
    {
      "name": "wasi:filesystem@0.2.0",
      "interfaces": {
        "types": 5,
        "preopens": 6
      },
      "worlds": {}
    },
    {
      "name": "wasi:sockets@0.2.0",
      "interfaces": {
        "network": 7,
        "instance-network": 8,
        "ip-name-lookup": 9,
        "tcp": 10,
        "tcp-create-socket": 11,
        "udp": 12,
        "udp-create-socket": 13
      },
      "worlds": {}
    },
    {
      "name": "wasi:random@0.2.0",
      "interfaces": {
        "insecure-seed": 14,
        "insecure": 15,
        "random": 16
      },
      "worlds": {}
    },
    {
      "name": "wasi:cli@0.2.0",
      "interfaces": {
        "environment": 17,
        "exit": 18,
        "run": 19,
        "stdin": 20,
        "stdout": 21,
        "stderr": 22,
        "terminal-input": 23,
        "terminal-output": 24,
        "terminal-stdin": 25,
        "terminal-stdout": 26,
        "terminal-stderr": 27
      },
      "worlds": {
        "command": 0
      }
    }
  ]
}